class Result{constructor(e,t){this.name=e,this.msecs=t}get total(){return this.msecs.reduce((e,t)=>e+t)}get fastest(){return this.msecs.reduce((e,t)=>Math.min(e,t))}get slowest(){return this.msecs.reduce((e,t)=>Math.max(e,t))}get average(){return this.total/this.msecs.length}get variance(){const e=this.average;return this.msecs.map(t=>Math.pow(t-e,2)).reduce((e,t)=>e+t)/(this.msecs.length-1)}get std(){return Math.sqrt(this.variance)}get sem(){return this.std/Math.sqrt(this.msecs.length)}get errorRange(){return 1.96*this.sem}get errorRate(){return this.errorRange/this.average}get opsPerSec(){return 1e3/this.average}toString(){const e=Math.round(1e4*this.average)/1e4,t=Math.round(1e3*this.opsPerSec)/1e3,a=Math.round(1e4*this.errorRange)/1e4,r=Math.round(1e4*this.errorRate)/100;return`${this.name}: ${t}ops/sec ${e}msec/op +-${a}msec/op (${r}%) / ${this.msecs.length} times tried`}}const now="undefined"!=typeof performance&&performance.now?function(){return performance.now()}:function(){const e=process.hrtime();return(1e9*e[0]+e[1])/1e6};class Benchmark{constructor(e={}){this.name=e.name||"unnamed",this.targetErrorRate=e.targetErrorRate||.1,this.maxNumber=e.maxNumber||1e4,this.minNumber=e.minNumber||30,this.number=e.number||null,"function"==typeof e?this.fun=e:(this.before=e.before||this.before,this.beforeEach=e.beforeEach||this.beforeEach,this.fun=e.fun||this.fun,this.afterEach=e.afterEach||this.afterEach,this.after=e.after||this.after)}async before(){}async beforeEach(e){}async fun(){throw new Error("target function is not defined")}async afterEach(e,t){}async after(e){console.log(String(e))}async run(e={}){(e=Object.assign({},e)).__proto__=this,await this.before.call(e);const t=this.number||this.maxNumber,a=[];for(let r=0;r<t;r++){const t=Object.assign({},e);await this.beforeEach.call(t,r);const s=now();await this.fun.call(t);const n=now();if(await this.afterEach.call(t,r,n-s),a.push(n-s),!this.number&&r+1>=this.minNumber&&new Result(this.name,a).errorRate<=this.targetErrorRate)break}const r=new Result(this.name,a);return await this.after.call(e,r),r}}class Suite{constructor(e={}){this.name=e.name||"unnamed",this.benchmarkDefault=e.benchmarkDefault||{},this.benchmarks=[],this.parallel=e.parallel||!1,this.before=e.before||this.before,this.beforeEach=e.beforeEach||this.beforeEach,this.afterEach=e.afterEach||this.afterEach,this.after=e.after||this.after}async before(){}async beforeEach(e,t){}async afterEach(e,t,a){}async after(e){}addBenchmark(e){return this.benchmarks.push(e),this}addSuite(e){return this.benchmarks.push(e),this}add(e){if(e instanceof Benchmark)this.addBenchmark(e);else if(e instanceof Suite)this.addSuite(e);else if("function"==typeof e){const t={fun:e};t.__proto__=this.benchmarkDefault,this.addBenchmark(new Benchmark(t))}else{const t=Object.assign({},e);t.__proto__=this.benchmarkDefault,this.addBenchmark(new Benchmark(t))}return this}async _runParallel(e){await this.before.call(e);const t=await Promise.all(this.benchmarks.map(async(t,a)=>{const r=Object.assign({},e);await this.beforeEach.call(r,a,t);const s=await t.run(r);return await this.afterEach.call(r,a,t,s),s}));return await this.after.call(e,t),t}async _runSequential(e){await this.before.call(e);const t=[];for(let a=0;a<this.benchmarks.length;a++){const r=this.benchmarks[a],s=Object.assign({},e);await this.beforeEach.call(s,a,r);const n=await r.run(s);t.push(n),await this.afterEach.call(s,a,r,n)}return await this.after.call(e,t),t}async run(e={}){return(e=Object.assign({},e)).__proto__=this,this.parallel?await this._runParallel(e):await this._runSequential(e)}}export default Benchmark;export{Result,Benchmark,Suite};
