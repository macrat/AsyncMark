import e from"assert";function t(t,s,r){return new e.AssertionError({message:`benchmark "${s.name}": actual:${s.average}msec/op ${t.operator} expected:${t.expected}msec/op`,actual:s.average+" msec/op",expected:t.expected+" msec/op",operator:t.operator,stackStartFn:r||t.assert})}function s(e,t,s){return Object.assign(new Error(`benchmark "${t.name}": actual:${t.average}msec/op ${e.operator} expected:${e.expected}msec/op`),{actual:t.average+" msec/op",expected:e.expected+" msec/op",operator:e.operator})}class r{constructor(r){const a=String(r).match(/^(|[<>]=?)(\d+(?:\.\d+)?)(|s|ms|us|ns|sec|msec|usec|nsec)$/);if(null===a)throw Error(`Invalid rule format: "${r}"`);this.operator=a[1]||"<=",this.expected=Number(a[2])*function(e){switch(e){case"s":case"sec":return 1e3;case"":case"ms":case"msec":return 1;case"us":case"usec":return.001;case"ns":case"nsec":return 1e-6;default:throw Error(`unknown unit name: "${e}"`)}}(a[3]),this.errorFn=void 0!==e?t:s}check(e){return{"<":e=>e<this.expected,"<=":e=>e<=this.expected,">":e=>e>this.expected,">=":e=>e>=this.expected}[this.operator](e)}assert(e,t=null){if(!this.check(e.average))throw this.errorFn(this,e,t)}}class a{constructor(e,t){this.name=e,this.msecs=t}get total(){return this.msecs.reduce((e,t)=>e+t)}get fastest(){return this.msecs.reduce((e,t)=>Math.min(e,t))}get slowest(){return this.msecs.reduce((e,t)=>Math.max(e,t))}get average(){return this.total/this.msecs.length}get variance(){const e=this.average;return this.msecs.map(t=>Math.pow(t-e,2)).reduce((e,t)=>e+t)/(this.msecs.length-1)}get std(){return Math.sqrt(this.variance)}get sem(){return this.std/Math.sqrt(this.msecs.length)}get errorRange(){return 1.96*this.sem}get errorRate(){return this.errorRange/this.average}get opsPerSec(){return 1e3/this.average}dropOutlier(e=2){const t=this.average,s=this.std;return new a(this.name,this.msecs.filter(r=>Math.abs((r-t)/s)<=e))}toString(){const e=Math.round(1e4*this.average)/1e4,t=Math.round(1e3*this.opsPerSec)/1e3,s=Math.round(1e4*this.errorRange)/1e4,r=Math.round(1e4*this.errorRate)/100;return`${this.name}:\t${t}ops/sec\t${e}msec/op\t+-${s}msec/op (${r}%)\t${this.msecs.length} times tried`}assert(...e){e.map(e=>new r(e)).forEach(e=>e.assert(this,this.assert))}}let n=function(){return Number(new Date)};async function c(e,t={},s=[]){const r=n();return await e.call(t,...s),n()-r}"undefined"!=typeof process&&process.hrtime?n=function(){const e=process.hrtime();return(1e9*e[0]+e[1])/1e6}:"undefined"!=typeof performance&&performance.now&&(n=function(){return performance.now()});class i{constructor(e={}){this.name=e.name||"unnamed",this.targetErrorRate=e.targetErrorRate||.1,this.maxNumber=e.maxNumber||1e4,this.minNumber=e.minNumber||30,this.number=e.number||null,"function"==typeof e?this.fun=e:(this.before=e.before||this.before,this.beforeEach=e.beforeEach||this.beforeEach,this.fun=e.fun||this.fun,this.afterEach=e.afterEach||this.afterEach,this.after=e.after||this.after)}async before(){}async beforeEach(e){}async fun(){throw new Error("target function is not defined")}async afterEach(e,t){}async after(e){console.log(String(e.dropOutlier()))}async run(e={},t={}){(e=Object.assign({},e)).__proto__=this,await this.before.call(e);const s=this.number||this.maxNumber,r=[];for(let n=0;n<s;n++){const s=Object.assign({},e);t.beforeTest&&await t.beforeTest.call(s,n,this),await this.beforeEach.call(s,n);const i=await c(this.fun,s);if(r.push(i),await this.afterEach.call(s,n,i),t.afterTest&&await t.afterTest.call(s,n,this,i),!this.number&&n+1>=this.minNumber&&new a(this.name,r).errorRate<=this.targetErrorRate)break}const n=new a(this.name,r);return await this.after.call(e,n),n}}class h{constructor(e={}){this.name=e.name||"unnamed",this.benchmarkDefault=e.benchmarkDefault||{},this.benchmarks=[],this.parallel=e.parallel||!1,this.before=e.before||this.before,this.beforeEach=e.beforeEach||this.beforeEach,this.beforeTest=e.beforeTest||this.beforeTest,this.afterTest=e.afterTest||this.afterTest,this.afterEach=e.afterEach||this.afterEach,this.after=e.after||this.after}async before(){}async beforeEach(e,t){}async beforeTest(e,t,s){}async afterTest(e,t,s,r){}async afterEach(e,t,s){}async after(e){}addBenchmark(e){return this.benchmarks.push(e),this}addSuite(e){return this.benchmarks.push(e),this}add(e){if(e instanceof i)this.addBenchmark(e);else if(e instanceof h)this.addSuite(e);else if("function"==typeof e){const t={fun:e};t.__proto__=this.benchmarkDefault,this.addBenchmark(new i(t))}else{const t=Object.assign({},e);t.__proto__=this.benchmarkDefault,this.addBenchmark(new i(t))}return this}_makeCallbacks(e,t){const s=this;return{beforeTest(r,a){t.beforeTest&&t.beforeTest.call(this,r,a),s.beforeTest.call(this,e,r,a)},afterTest(r,a,n){s.afterTest.call(this,e,r,a,n),t.afterTest&&t.afterTest.call(this,r,a,n)}}}async _runParallel(e,t){await this.before.call(e);const s=await Promise.all(this.benchmarks.map(async(s,r)=>{const a=Object.assign({},e);await this.beforeEach.call(a,r,s);const n=await s.run(a,this._makeCallbacks(r,t));return await this.afterEach.call(a,r,s,n),n}));return await this.after.call(e,s),s}async _runSequential(e,t){await this.before.call(e);const s=[];for(let r=0;r<this.benchmarks.length;r++){const a=this.benchmarks[r],n=Object.assign({},e);await this.beforeEach.call(n,r,a);const c=await a.run(n,this._makeCallbacks(r,t));s.push(c),await this.afterEach.call(n,r,a,c)}return await this.after.call(e,s),s}async run(e={},t={}){return(e=Object.assign({},e)).__proto__=this,this.parallel?await this._runParallel(e,t):await this._runSequential(e,t)}}export default i;export{i as Benchmark,a as Result,h as Suite,c as timeit};
