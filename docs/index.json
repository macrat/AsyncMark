[
  {
    "__docId__": 0,
    "kind": "file",
    "name": "dist/asyncmark.mjs",
    "content": "/**\n * milliseconds timer\n *\n * @return {Number} high resolution current time in milliseconds.\n *\n * @ignore\n */\nconst now = typeof performance !== 'undefined' && performance.now ? function () {\n  return performance.now();\n} : function () {\n  const hr = process.hrtime();\n  return (hr[0] * 1e9 + hr[1]) / 1e6;\n};\n\n/**\n * The result of benchmark.\n */\nclass Result {\n  /**\n   * @param {String} name - name of benchmark.\n   * @param {Number[]} msecs - times of benchmark result.\n   *\n   * @ignore\n   */\n  constructor(name, msecs) {\n    /**\n     * Name of this test.\n     *\n     * @type {String}\n     */\n    this.name = name;\n\n    /**\n     * Times of benchmark result in milliseconds.\n     *\n     * @type {Number[]}\n     */\n    this.msecs = msecs;\n  }\n\n  /**\n   * Total milliseconds of this benchmark.\n   *\n   * @type {Number}\n   */\n  get total() {\n    return this.msecs.reduce((x, y) => x + y);\n  }\n\n  /**\n   * Average time of this benchmark in milliseconds.\n   *\n   * @type {Number}\n   */\n  get average() {\n    return this.total / this.msecs.length;\n  }\n\n  /**\n   * Time unbiased sample variance of times.\n   *\n   * @type {Number}\n   */\n  get variance() {\n    const avg = this.average;\n    return this.msecs.map(x => Math.pow(x - avg, 2)).reduce((x, y) => x + y) / (this.msecs.length - 1);\n  }\n\n  /**\n   * Standard division of times.\n   *\n   * @type {Number}\n   */\n  get std() {\n    return Math.sqrt(this.variance);\n  }\n\n  /**\n   * Standard error of the mean of times.\n   *\n   * @type {Number}\n   */\n  get sem() {\n    return this.std / Math.sqrt(this.msecs.length);\n  }\n\n  /**\n   * Guessed error range of this benchmark.\n   *\n   * @type {Number}\n   */\n  get errorRange() {\n    return this.sem * 1.96;\n  }\n\n  /**\n   * Error range per average time.\n   *\n   * @type {Number}\n   */\n  get errorRate() {\n    return this.errorRange / this.average;\n  }\n\n  /**\n   * Operations per seconds.\n   *\n   * @type {Number}\n   */\n  get opsPerSec() {\n    return 1000 / this.average;\n  }\n\n  /**\n   * Convert to string for printing.\n   *\n   * @return {String} human redable string\n   */\n  toString() {\n    const avg = Math.round(this.average * 10000) / 10000;\n    const ops = Math.round(this.opsPerSec * 1000) / 1000;\n    const range = Math.round(this.errorRange * 10000) / 10000;\n    const rate = Math.round(this.errorRate * 10000) / 100;\n    return `${this.name}: ${ops}ops/sec ${avg}msec/op +-${range}msec/op (${rate}%) / ${this.msecs.length} times tried`;\n  }\n}\n\n/**\n * Class for benchmarking.\n *\n * Benchmark will execute by flow like this.\n *\n *   - before\n *   - beforeEach\n *   - fun\n *   - afterEach\n *   - after\n *\n * Each function can override with options of the constructor.\n *\n *\n * @example\n * import Benchmark from 'asyncmark';\n *\n *\n * new Benchmark({\n *     name: 'timeout',\n *     fun() {\n *         return new Promise((resolve, reject) => {\n *             setTimeout(resolve, 100);\n *         });\n *     },\n * }).run().catch(console.error);\n */\nclass Benchmark {\n  /**\n   * @param {Object|function} [options] - options for this benchmark or benchmarking function.\n   * @param {Number} [options.name='unnamed'] - name of this benchmark.\n   * @param {Number} [options.targetErrorRate=0.1] - wanted maximum error rate. see {@link Benchmark#targetErrorRate}.\n   * @param {Number} [options.maxNumber=10000] - maximum number of executing test. see {@link Benchmark#maxNumber}.\n   * @param {Number} [options.minNumber=30] - minimal number of executing test. see {@link Benchmark#minNumber}.\n   * @param {Number} [options.number] - the number of executing the test. see {@link Benchmark#number}.\n   * @param {function(): ?Promise} [options.before] - setup function. see {@link Benchmark#before}.\n   * @param {function(count: Number): ?Promise} [options.beforeEach] - setup function. see {@link Benchmark#beforeEach}.\n   * @param {function(): ?Promise} [options.fun] - target function for benchmarking. see {@link Benchmark#fun}.\n   * @param {function(count: Number, msec: Number): ?Promise} [options.afterEach] - teardown function. see {@link Benchmark#afterEach}.\n   * @param {function(result: Result): ?Promise} [options.after] - teardown function. see {@link Benchmark#after}.\n   */\n  constructor(options = {}) {\n    /**\n     * Name of this benchmark.\n     *\n     * @type {String}\n     */\n    this.name = options.name || 'unnamed';\n\n    /**\n     * Wanted maximum error rate.\n     * This value will be ignore if set {@link Benchmark#number}.\n     *\n     * @type {Number}\n     */\n    this.targetErrorRate = options.targetErrorRate || 0.1;\n\n    /**\n     * Maximum number of executing test.\n     * This value will be ignore if set {@link Benchmark#number}.\n     *\n     * @type {Number}\n     */\n    this.maxNumber = options.maxNumber || 10000;\n\n    /**\n     * Minimal number of executing test.\n     * This value will be ignore if set {@link Benchmark#number}.\n     *\n     * @type {Number}\n     */\n    this.minNumber = options.minNumber || 30;\n\n    /**\n     * The number of executing the test.\n     * Will decide automatically in between {@link Benchmark#minNumber} to {@link Benchmark#maxNumber} if set null.\n     *\n     * @type {Number|null}\n     */\n    this.number = options.number || null;\n\n    if (typeof options === 'function') {\n      this.fun = options;\n    } else {\n      this.before = options.before || this.before;\n      this.beforeEach = options.beforeEach || this.beforeEach;\n      this.fun = options.fun || this.fun;\n      this.afterEach = options.afterEach || this.afterEach;\n      this.after = options.after || this.after;\n    }\n  }\n\n  /**\n   * Setup before execute benchmark.\n   *\n   * At the time executing this method, `this` is the unique object for the benchmark.\n   * So you can use `this` for storing testing data like a database.\n   * Data of `this` that set in this method will discard after call {@link Benchmark#after}\n   *\n   * In default, do nothing.\n   *\n   * @return {?Promise} {@link Benchmark} will await if returns {@link Promise}. Resolved value never evaluation.\n   */\n  async before() {}\n\n  /**\n   * Setup before each tests.\n   *\n   * At the time executing this method, `this` is the unique object for the test.\n   * So you can use `this` for storing testing data.\n   * Data of `this` that set in this method will discard after call {@link Benchmark#afterEach}\n   *\n   * In default, do nothing.\n   *\n   * @param {Number} count - count of done tests in this benchmark.\n   *\n   * @return {?Promise} {@link Benchmark} will await if returns {@link Promise}. Resolved value never evaluation.\n   */\n  async beforeEach(count) {}\n\n  /**\n   * The target function for benchmarking.\n   *\n   * At the time executing this method, `this` is the unique object for the test.\n   * So you can use `this` for storing testing data.\n   * Data of `this` that set in this method will discard after call {@link Benchmark#afterEach}\n   *\n   * In default, couses error that `Error('target function is not defined')`.\n   *\n   * @abstract\n   *\n   * @return {?Promise} If returns {@link Promise}, {@link Benchmark} will measure the time it takes for the Promise to resolve. Otherwise will measure the time it to method return.\n   */\n  async fun() {\n    throw new Error('target function is not defined');\n  }\n\n  /**\n   * Teardown after each tests.\n   *\n   * At the time executing this method, `this` is the unique object for the test.\n   * So you can use `this` for storing testing data.\n   * Data of `this` that set in this method will discard after call this method.\n   *\n   * In default, do nothing.\n   *\n   * @param {Number} count - count of done tests in this benchmark.\n   * @param {Number} msec - duration of this execution.\n   *\n   * @return {?Promise} {@link Benchmark} will await if returns {@link Promise}. Resolved value never evaluation.\n   */\n  async afterEach(count, msec) {}\n\n  /**\n   * Teardown after execute benchmark.\n   *\n   * At the time executing this method, `this` is the unique object for the benchmark.\n   * So you can use `this` for storing testing data like a database.\n   * Data of `this` that set in this method will discard after call this method.\n   *\n   * In default, shows test result.\n   *\n   * @param {Result} result - result of this benchmark.\n   *\n   * @return {?Promise} {@link Benchmark} will await if returns {@link Promise}. Resolved value never evaluation.\n   */\n  async after(result) {\n    console.log(String(result));\n  }\n\n  /**\n   * Execute benchmark.\n   *\n   * @param {Object} [context={}] - the `this` for each benchmarking functions. `__proto__` will override with this instance.\n   *\n   * @return {?Promise<Result>} A result of benchmark.\n   */\n  async run(context = {}) {\n    context = Object.assign({}, context);\n    context.__proto__ = this;\n\n    await this.before.call(context);\n\n    const loopNum = this.number || this.maxNumber;\n\n    const msecs = [];\n    for (let i = 0; i < loopNum; i++) {\n      const ctx = Object.assign({}, context);\n\n      await this.beforeEach.call(ctx, i);\n\n      const start = now();\n      await this.fun.call(ctx);\n      const end = now();\n\n      await this.afterEach.call(ctx, i, end - start);\n      msecs.push(end - start);\n\n      if (!this.number && i + 1 >= this.minNumber && new Result(this.name, msecs).errorRate <= this.targetErrorRate) {\n        break;\n      }\n    }\n\n    const result = new Result(this.name, msecs);\n    await this.after.call(context, result);\n    return result;\n  }\n}\n\n/**\n * A set of {@link Benchmark}s for executing those sequential or parallel.\n *\n * Suite will execute by flow like this.\n *\n *   - {@link Suite#before}\n *   - {@link Suite#beforeEach}\n *   - {@link Benchmark#before}\n *   - {@link Benchmark#beforeEach}\n *   - {@link Benchmark#fun}\n *   - {@link Benchmark#afterEach}\n *   - {@link Benchmark#after}\n *   - {@link Suite#afterEach}\n *   - {@link Suite#after}\n *\n * Each function can override with options of the constructor.\n *\n *\n * @example\n * import {Suite} from 'asyncmark';\n *\n *\n * const suite = new Suite({\n *     name: 'ways to find a character',\n *     beforeEach() {\n *         this.text = 'hello world';\n *     },\n *     parallel: true,\n * });\n *\n * suite.add(function() {\n *     /o/.test(this.text);\n * });\n *\n * suite.add({\n *     name: 'String#indexOf',\n *     before() {\n *         console.log('starting String#indexOf...');\n *     },\n *     fun() {\n *         this.text.indexOf('o') > -1;\n *     },\n * });\n *\n * suite.add(new Benchmark({\n *     name: 'String#match',\n *     fun() {\n *         Boolean(this.text.match(/o/));\n *     },\n *     after(result) {\n *         console.log('String#match is done! ' + result);\n *     },\n * }));\n *\n * suite.run()\n *     .then(results => {\n *         let min = results[0];\n *         results.forEach(x => {\n *             if (min.average > x.average) {\n *                 min = x;\n *             }\n *         });\n *         console.log(min.name + ' is best way!');\n *     }).\n *     catch(err => console.error(err));\n */\nclass Suite {\n  /**\n   * @param {Object} [options={}] - options for this suite.\n   * @param {Number} [options.name='unnamed'] - name of this suite.\n   * @param {Boolean} [options.parallel=false] - flag for executing each benchmark parallelly.\n   * @param {function(): ?Promise} [options.before] - setup function. see {@link Suite#before}.\n   * @param {function(count: Number, benchmark: Benchmark): ?Promise} [options.beforeEach] - setup function. see {@link Suite#before}.\n   * @param {function(count: Number, benchmark: Benchmark): ?Promise} [options.afterEach] - setup function. see {@link Suite#after}.\n   * @param {function(results: Result[]): ?Promise} [options.after] - setup function. see {@link Suite#after}.\n   * @param {Object} [options.benchmarkDefault={}] - default options for {@link Suite#add}.\n   */\n  constructor(options = {}) {\n    /**\n     * Name of this suite.\n     *\n     * @type {String}\n     */\n    this.name = options.name || 'unnamed';\n\n    /**\n     * Default options for benchmarks in this suite.\n     *\n     * @type {Object}\n     */\n    this.benchmarkDefault = options.benchmarkDefault || {};\n\n    /**\n     * A list of {@link Benchmark}.\n     *\n     * @type {Benchmark[]}\n     */\n    this.benchmarks = [];\n\n    /**\n     * Flag for executing each benchmark parallelly.\n     *\n     * @type {Boolean}\n     */\n    this.parallel = options.parallel || false;\n\n    this.before = options.before || this.before;\n    this.beforeEach = options.beforeEach || this.beforeEach;\n    this.afterEach = options.afterEach || this.afterEach;\n    this.after = options.after || this.after;\n  }\n\n  /**\n   * Setup before execute all benchmarks.\n   *\n   * At the time executing this method, `this` is the unique object for the suite.\n   * So you can use `this` for storing testing data like a database.\n   * Data of `this` that set in this method will discard after call {@link Suite#after}\n   *\n   * In default, do nothing.\n   *\n   * @return {?Promise} {@link Suite} will await if returns {@link Promise}. Resolved value never evaluation.\n   */\n  async before() {}\n\n  /**\n   * Setup before execute each benchmark.\n   *\n   * At the time executing this method, `this` is the unique object for the test.\n   * So you can use `this` for storing testing data like a database.\n   * Data of `this` that set in this method will discard after call {@link Suite#afterEach}\n   *\n   * In default, do nothing.\n   *\n   * @param {Number} count - count of done benchmarks in this benchmark.\n   * @param {Benchmark} benchmark - a {@link Benchmark} instance that will execute.\n   *\n   * @return {?Promise} {@link Suite} will await if returns {@link Promise}. Resolved value never evaluation.\n   */\n  async beforeEach(count, benchmark) {}\n\n  /**\n   * Teardown after execute each benchmark.\n   *\n   * At the time executing this method, `this` is the unique object for the test.\n   * So you can use `this` for storing testing data like a database.\n   * Data of `this` that set in this method will discard after call this method.\n   *\n   * In default, do nothing.\n   *\n   * @param {Number} count - count of done benchmarks in this benchmark.\n   * @param {Benchmark} benchmark - a {@link Benchmark} instance that executed.\n   * @param {Result} result - a result of this benchmark.\n   *\n   * @return {?Promise} {@link Suite} will await if returns {@link Promise}. Resolved value never evaluation.\n   */\n  async afterEach(count, benchmark, result) {}\n\n  /**\n   * Teardown after execute all benchmarks.\n   *\n   * At the time executing this method, `this` is the unique object for the suite.\n   * So you can use `this` for storing testing data like a database.\n   * Data of `this` that set in this method will discard after call this method.\n   *\n   * In default, do nothing.\n   *\n   * @param {Result[]} results - a list of benchmark result.\n   *\n   * @return {?Promise} {@link Suite} will await if returns {@link Promise}. Resolved value never evaluation.\n   */\n  async after(results) {}\n\n  /**\n   * Adding {@link Benchmark} instance into this {@link Suite}.\n   *\n   * @param {Benchmark} benchmark - the benchmark instance for adding.\n   *\n   * @return {Suite} returns this suite for method chain.\n   */\n  addBenchmark(benchmark) {\n    this.benchmarks.push(benchmark);\n    return this;\n  }\n\n  /**\n   * Adding child {@link Suite} instance into this {@link Suite}.\n   *\n   * @param {Suite} suite - the suite instance for adding.\n   *\n   * @return {Suite} returns this suite for method chain.\n   */\n  addSuite(suite) {\n    this.benchmarks.push(suite);\n    return this;\n  }\n\n  /**\n   * Make new benchmark or suite and adding into this {@link Suite}.\n   *\n   * @param {Benchmark|Suite|Object|function} [child={}] - {@link Benchmark}, {@link Suite}, or arguments for {@link Benchmark#constructor}.\n   *\n   * @return {Suite} returns this suite for method chain.\n   */\n  add(child = {}) {\n    if (child instanceof Benchmark) {\n      this.addBenchmark(child);\n    } else if (child instanceof Suite) {\n      this.addSuite(child);\n    } else if (typeof child === 'function') {\n      const options = { fun: child };\n      options.__proto__ = this.benchmarkDefault;\n      this.addBenchmark(new Benchmark(options));\n    } else {\n      const options = Object.assign({}, child);\n      options.__proto__ = this.benchmarkDefault;\n      this.addBenchmark(new Benchmark(options));\n    }\n    return this;\n  }\n\n  /**\n   * Execute benchmarks parallelly.\n   *\n   * @param {object} context - the context for execute.\n   *\n   * @return {Promise<Result[]>} result of benchmarks.\n   *\n   * @ignore\n   */\n  async _runParallel(context) {\n    await this.before.call(context);\n\n    const results = await Promise.all(this.benchmarks.map(async (x, i) => {\n      const ctx = Object.assign({}, context);\n      await this.beforeEach.call(ctx, i, x);\n      const result = await x.run(ctx);\n      await this.afterEach.call(ctx, i, x, result);\n      return result;\n    }));\n\n    await this.after.call(context, results);\n\n    return results;\n  }\n\n  /**\n   * Execute benchmarks sequential.\n   *\n   * @param {object} context - the context for execute.\n   *\n   * @return {Promise<Result[]>} result of benchmarks.\n   *\n   * @ignore\n   */\n  async _runSequential(context) {\n    await this.before.call(context);\n\n    const results = [];\n    for (let i = 0; i < this.benchmarks.length; i++) {\n      const b = this.benchmarks[i];\n      const ctx = Object.assign({}, context);\n      await this.beforeEach.call(ctx, i, b);\n      const result = await b.run(ctx);\n      results.push(result);\n      await this.afterEach.call(ctx, i, b, result);\n    }\n\n    await this.after.call(context, results);\n\n    return results;\n  }\n\n  /**\n   * Execute benchmarks in this suite.\n   *\n   * All benchmarks will execute parallel if enabled {@link Suite#parallel} option.\n   * Else do execute sequentially by added order.\n   *\n   * @param {Object} [context={}] - the `this` for each benchmarking functions. `__proto__` will override with this instance.\n   *\n   * @return {Promise<Result[]>} An array of {@link Result}s.\n   */\n  async run(context = {}) {\n    context = Object.assign({}, context);\n    context.__proto__ = this;\n\n    if (this.parallel) {\n      return await this._runParallel(context);\n    } else {\n      return await this._runSequential(context);\n    }\n  }\n}\n\nexport default Benchmark;\nexport { Result, Benchmark, Suite };\n",
    "static": true,
    "longname": "/home/ena/AsyncMark/dist/asyncmark.mjs",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1,
    "kind": "variable",
    "name": "now",
    "memberof": "dist/asyncmark.mjs",
    "static": true,
    "longname": "dist/asyncmark.mjs~now",
    "access": "public",
    "export": false,
    "importPath": "asyncmark/dist/asyncmark.mjs",
    "importStyle": null,
    "description": "milliseconds timer",
    "lineNumber": 8,
    "ignore": true,
    "return": {
      "nullable": null,
      "types": [
        "Number"
      ],
      "spread": false,
      "description": "high resolution current time in milliseconds."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2,
    "kind": "class",
    "name": "Benchmark",
    "memberof": "dist/asyncmark.mjs",
    "static": true,
    "longname": "dist/asyncmark.mjs~Benchmark",
    "access": "public",
    "export": true,
    "importPath": "asyncmark/dist/asyncmark.mjs",
    "importStyle": "Benchmark",
    "description": "Class for benchmarking.\n\nBenchmark will execute by flow like this.\n\n  - before\n  - beforeEach\n  - fun\n  - afterEach\n  - after\n\nEach function can override with options of the constructor.",
    "examples": [
      "import Benchmark from 'asyncmark';\n\n\nnew Benchmark({\n    name: 'timeout',\n    fun() {\n        return new Promise((resolve, reject) => {\n            setTimeout(resolve, 100);\n        });\n    },\n}).run().catch(console.error);"
    ],
    "lineNumber": 155,
    "interface": false
  },
  {
    "__docId__": 3,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "dist/asyncmark.mjs~Benchmark",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "dist/asyncmark.mjs~Benchmark#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 169,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object",
          "function"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "options for this benchmark or benchmarking function."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'unnamed'",
        "defaultRaw": "'unnamed'",
        "name": "options.name",
        "description": "name of this benchmark."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "0.1",
        "defaultRaw": 0.1,
        "name": "options.targetErrorRate",
        "description": "wanted maximum error rate. see {@link Benchmark#targetErrorRate}."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "10000",
        "defaultRaw": 10000,
        "name": "options.maxNumber",
        "description": "maximum number of executing test. see {@link Benchmark#maxNumber}."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "30",
        "defaultRaw": 30,
        "name": "options.minNumber",
        "description": "minimal number of executing test. see {@link Benchmark#minNumber}."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "name": "options.number",
        "description": "the number of executing the test. see {@link Benchmark#number}."
      },
      {
        "nullable": null,
        "types": [
          "function(): ?Promise"
        ],
        "spread": false,
        "optional": true,
        "name": "options.before",
        "description": "setup function. see {@link Benchmark#before}."
      },
      {
        "nullable": null,
        "types": [
          "function(count: Number): ?Promise"
        ],
        "spread": false,
        "optional": true,
        "name": "options.beforeEach",
        "description": "setup function. see {@link Benchmark#beforeEach}."
      },
      {
        "nullable": null,
        "types": [
          "function(): ?Promise"
        ],
        "spread": false,
        "optional": true,
        "name": "options.fun",
        "description": "target function for benchmarking. see {@link Benchmark#fun}."
      },
      {
        "nullable": null,
        "types": [
          "function(count: Number, msec: Number): ?Promise"
        ],
        "spread": false,
        "optional": true,
        "name": "options.afterEach",
        "description": "teardown function. see {@link Benchmark#afterEach}."
      },
      {
        "nullable": null,
        "types": [
          "function(result: Result): ?Promise"
        ],
        "spread": false,
        "optional": true,
        "name": "options.after",
        "description": "teardown function. see {@link Benchmark#after}."
      }
    ]
  },
  {
    "__docId__": 4,
    "kind": "member",
    "name": "name",
    "memberof": "dist/asyncmark.mjs~Benchmark",
    "static": false,
    "longname": "dist/asyncmark.mjs~Benchmark#name",
    "access": "public",
    "description": "Name of this benchmark.",
    "lineNumber": 175,
    "type": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 5,
    "kind": "member",
    "name": "targetErrorRate",
    "memberof": "dist/asyncmark.mjs~Benchmark",
    "static": false,
    "longname": "dist/asyncmark.mjs~Benchmark#targetErrorRate",
    "access": "public",
    "description": "Wanted maximum error rate.\nThis value will be ignore if set {@link Benchmark#number}.",
    "lineNumber": 183,
    "type": {
      "nullable": null,
      "types": [
        "Number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 6,
    "kind": "member",
    "name": "maxNumber",
    "memberof": "dist/asyncmark.mjs~Benchmark",
    "static": false,
    "longname": "dist/asyncmark.mjs~Benchmark#maxNumber",
    "access": "public",
    "description": "Maximum number of executing test.\nThis value will be ignore if set {@link Benchmark#number}.",
    "lineNumber": 191,
    "type": {
      "nullable": null,
      "types": [
        "Number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 7,
    "kind": "member",
    "name": "minNumber",
    "memberof": "dist/asyncmark.mjs~Benchmark",
    "static": false,
    "longname": "dist/asyncmark.mjs~Benchmark#minNumber",
    "access": "public",
    "description": "Minimal number of executing test.\nThis value will be ignore if set {@link Benchmark#number}.",
    "lineNumber": 199,
    "type": {
      "nullable": null,
      "types": [
        "Number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 8,
    "kind": "member",
    "name": "number",
    "memberof": "dist/asyncmark.mjs~Benchmark",
    "static": false,
    "longname": "dist/asyncmark.mjs~Benchmark#number",
    "access": "public",
    "description": "The number of executing the test.\nWill decide automatically in between {@link Benchmark#minNumber} to {@link Benchmark#maxNumber} if set null.",
    "lineNumber": 207,
    "type": {
      "nullable": null,
      "types": [
        "Number",
        "null"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 15,
    "kind": "method",
    "name": "before",
    "memberof": "dist/asyncmark.mjs~Benchmark",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "dist/asyncmark.mjs~Benchmark#before",
    "access": "public",
    "description": "Setup before execute benchmark.\n\nAt the time executing this method, `this` is the unique object for the benchmark.\nSo you can use `this` for storing testing data like a database.\nData of `this` that set in this method will discard after call {@link Benchmark#after}\n\nIn default, do nothing.",
    "lineNumber": 231,
    "return": {
      "nullable": true,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "{@link Benchmark} will await if returns {@link Promise}. Resolved value never evaluation."
    },
    "params": []
  },
  {
    "__docId__": 16,
    "kind": "method",
    "name": "beforeEach",
    "memberof": "dist/asyncmark.mjs~Benchmark",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "dist/asyncmark.mjs~Benchmark#beforeEach",
    "access": "public",
    "description": "Setup before each tests.\n\nAt the time executing this method, `this` is the unique object for the test.\nSo you can use `this` for storing testing data.\nData of `this` that set in this method will discard after call {@link Benchmark#afterEach}\n\nIn default, do nothing.",
    "lineNumber": 246,
    "params": [
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "count",
        "description": "count of done tests in this benchmark."
      }
    ],
    "return": {
      "nullable": true,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "{@link Benchmark} will await if returns {@link Promise}. Resolved value never evaluation."
    }
  },
  {
    "__docId__": 17,
    "kind": "method",
    "name": "fun",
    "memberof": "dist/asyncmark.mjs~Benchmark",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "dist/asyncmark.mjs~Benchmark#fun",
    "access": "public",
    "description": "The target function for benchmarking.\n\nAt the time executing this method, `this` is the unique object for the test.\nSo you can use `this` for storing testing data.\nData of `this` that set in this method will discard after call {@link Benchmark#afterEach}\n\nIn default, couses error that `Error('target function is not defined')`.",
    "lineNumber": 261,
    "return": {
      "nullable": true,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "If returns {@link Promise}, {@link Benchmark} will measure the time it takes for the Promise to resolve. Otherwise will measure the time it to method return."
    },
    "abstract": true,
    "params": []
  },
  {
    "__docId__": 18,
    "kind": "method",
    "name": "afterEach",
    "memberof": "dist/asyncmark.mjs~Benchmark",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "dist/asyncmark.mjs~Benchmark#afterEach",
    "access": "public",
    "description": "Teardown after each tests.\n\nAt the time executing this method, `this` is the unique object for the test.\nSo you can use `this` for storing testing data.\nData of `this` that set in this method will discard after call this method.\n\nIn default, do nothing.",
    "lineNumber": 279,
    "params": [
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "count",
        "description": "count of done tests in this benchmark."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "msec",
        "description": "duration of this execution."
      }
    ],
    "return": {
      "nullable": true,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "{@link Benchmark} will await if returns {@link Promise}. Resolved value never evaluation."
    }
  },
  {
    "__docId__": 19,
    "kind": "method",
    "name": "after",
    "memberof": "dist/asyncmark.mjs~Benchmark",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "dist/asyncmark.mjs~Benchmark#after",
    "access": "public",
    "description": "Teardown after execute benchmark.\n\nAt the time executing this method, `this` is the unique object for the benchmark.\nSo you can use `this` for storing testing data like a database.\nData of `this` that set in this method will discard after call this method.\n\nIn default, shows test result.",
    "lineNumber": 294,
    "params": [
      {
        "nullable": null,
        "types": [
          "Result"
        ],
        "spread": false,
        "optional": false,
        "name": "result",
        "description": "result of this benchmark."
      }
    ],
    "return": {
      "nullable": true,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "{@link Benchmark} will await if returns {@link Promise}. Resolved value never evaluation."
    }
  },
  {
    "__docId__": 20,
    "kind": "method",
    "name": "run",
    "memberof": "dist/asyncmark.mjs~Benchmark",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "dist/asyncmark.mjs~Benchmark#run",
    "access": "public",
    "description": "Execute benchmark.",
    "lineNumber": 305,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{}",
        "defaultRaw": {},
        "name": "context",
        "description": "the `this` for each benchmarking functions. `__proto__` will override with this instance."
      }
    ],
    "return": {
      "nullable": true,
      "types": [
        "Promise<Result>"
      ],
      "spread": false,
      "description": "A result of benchmark."
    }
  },
  {
    "__docId__": 21,
    "kind": "class",
    "name": "Result",
    "memberof": "dist/asyncmark.mjs",
    "static": true,
    "longname": "dist/asyncmark.mjs~Result",
    "access": "public",
    "export": true,
    "importPath": "asyncmark/dist/asyncmark.mjs",
    "importStyle": "{Result}",
    "description": "The result of benchmark.",
    "lineNumber": 18,
    "interface": false
  },
  {
    "__docId__": 22,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "dist/asyncmark.mjs~Result",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "dist/asyncmark.mjs~Result#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 25,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "name of benchmark."
      },
      {
        "nullable": null,
        "types": [
          "Number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "msecs",
        "description": "times of benchmark result."
      }
    ]
  },
  {
    "__docId__": 23,
    "kind": "member",
    "name": "name",
    "memberof": "dist/asyncmark.mjs~Result",
    "static": false,
    "longname": "dist/asyncmark.mjs~Result#name",
    "access": "public",
    "description": "Name of this test.",
    "lineNumber": 31,
    "type": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 24,
    "kind": "member",
    "name": "msecs",
    "memberof": "dist/asyncmark.mjs~Result",
    "static": false,
    "longname": "dist/asyncmark.mjs~Result#msecs",
    "access": "public",
    "description": "Times of benchmark result in milliseconds.",
    "lineNumber": 38,
    "type": {
      "nullable": null,
      "types": [
        "Number[]"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 25,
    "kind": "get",
    "name": "total",
    "memberof": "dist/asyncmark.mjs~Result",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "dist/asyncmark.mjs~Result#total",
    "access": "public",
    "description": "Total milliseconds of this benchmark.",
    "lineNumber": 46,
    "type": {
      "nullable": null,
      "types": [
        "Number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 26,
    "kind": "get",
    "name": "average",
    "memberof": "dist/asyncmark.mjs~Result",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "dist/asyncmark.mjs~Result#average",
    "access": "public",
    "description": "Average time of this benchmark in milliseconds.",
    "lineNumber": 55,
    "type": {
      "nullable": null,
      "types": [
        "Number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 27,
    "kind": "get",
    "name": "variance",
    "memberof": "dist/asyncmark.mjs~Result",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "dist/asyncmark.mjs~Result#variance",
    "access": "public",
    "description": "Time unbiased sample variance of times.",
    "lineNumber": 64,
    "type": {
      "nullable": null,
      "types": [
        "Number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 28,
    "kind": "get",
    "name": "std",
    "memberof": "dist/asyncmark.mjs~Result",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "dist/asyncmark.mjs~Result#std",
    "access": "public",
    "description": "Standard division of times.",
    "lineNumber": 74,
    "type": {
      "nullable": null,
      "types": [
        "Number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 29,
    "kind": "get",
    "name": "sem",
    "memberof": "dist/asyncmark.mjs~Result",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "dist/asyncmark.mjs~Result#sem",
    "access": "public",
    "description": "Standard error of the mean of times.",
    "lineNumber": 83,
    "type": {
      "nullable": null,
      "types": [
        "Number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 30,
    "kind": "get",
    "name": "errorRange",
    "memberof": "dist/asyncmark.mjs~Result",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "dist/asyncmark.mjs~Result#errorRange",
    "access": "public",
    "description": "Guessed error range of this benchmark.",
    "lineNumber": 92,
    "type": {
      "nullable": null,
      "types": [
        "Number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 31,
    "kind": "get",
    "name": "errorRate",
    "memberof": "dist/asyncmark.mjs~Result",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "dist/asyncmark.mjs~Result#errorRate",
    "access": "public",
    "description": "Error range per average time.",
    "lineNumber": 101,
    "type": {
      "nullable": null,
      "types": [
        "Number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 32,
    "kind": "get",
    "name": "opsPerSec",
    "memberof": "dist/asyncmark.mjs~Result",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "dist/asyncmark.mjs~Result#opsPerSec",
    "access": "public",
    "description": "Operations per seconds.",
    "lineNumber": 110,
    "type": {
      "nullable": null,
      "types": [
        "Number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 33,
    "kind": "method",
    "name": "toString",
    "memberof": "dist/asyncmark.mjs~Result",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "dist/asyncmark.mjs~Result#toString",
    "access": "public",
    "description": "Convert to string for printing.",
    "lineNumber": 119,
    "return": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": "human redable string"
    },
    "params": []
  },
  {
    "__docId__": 34,
    "kind": "class",
    "name": "Suite",
    "memberof": "dist/asyncmark.mjs",
    "static": true,
    "longname": "dist/asyncmark.mjs~Suite",
    "access": "public",
    "export": true,
    "importPath": "asyncmark/dist/asyncmark.mjs",
    "importStyle": "{Suite}",
    "description": "A set of {@link Benchmark}s for executing those sequential or parallel.\n\nSuite will execute by flow like this.\n\n  - {@link Suite#before}\n  - {@link Suite#beforeEach}\n  - {@link Benchmark#before}\n  - {@link Benchmark#beforeEach}\n  - {@link Benchmark#fun}\n  - {@link Benchmark#afterEach}\n  - {@link Benchmark#after}\n  - {@link Suite#afterEach}\n  - {@link Suite#after}\n\nEach function can override with options of the constructor.",
    "examples": [
      "import {Suite} from 'asyncmark';\n\n\nconst suite = new Suite({\n    name: 'ways to find a character',\n    beforeEach() {\n        this.text = 'hello world';\n    },\n    parallel: true,\n});\n\nsuite.add(function() {\n    /o/.test(this.text);\n});\n\nsuite.add({\n    name: 'String#indexOf',\n    before() {\n        console.log('starting String#indexOf...');\n    },\n    fun() {\n        this.text.indexOf('o') > -1;\n    },\n});\n\nsuite.add(new Benchmark({\n    name: 'String#match',\n    fun() {\n        Boolean(this.text.match(/o/));\n    },\n    after(result) {\n        console.log('String#match is done! ' + result);\n    },\n}));\n\nsuite.run()\n    .then(results => {\n        let min = results[0];\n        results.forEach(x => {\n            if (min.average > x.average) {\n                min = x;\n            }\n        });\n        console.log(min.name + ' is best way!');\n    }).\n    catch(err => console.error(err));"
    ],
    "lineNumber": 403,
    "interface": false
  },
  {
    "__docId__": 35,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "dist/asyncmark.mjs~Suite",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "dist/asyncmark.mjs~Suite#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 414,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{}",
        "defaultRaw": {},
        "name": "options",
        "description": "options for this suite."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'unnamed'",
        "defaultRaw": "'unnamed'",
        "name": "options.name",
        "description": "name of this suite."
      },
      {
        "nullable": null,
        "types": [
          "Boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.parallel",
        "description": "flag for executing each benchmark parallelly."
      },
      {
        "nullable": null,
        "types": [
          "function(): ?Promise"
        ],
        "spread": false,
        "optional": true,
        "name": "options.before",
        "description": "setup function. see {@link Suite#before}."
      },
      {
        "nullable": null,
        "types": [
          "function(count: Number, benchmark: Benchmark): ?Promise"
        ],
        "spread": false,
        "optional": true,
        "name": "options.beforeEach",
        "description": "setup function. see {@link Suite#before}."
      },
      {
        "nullable": null,
        "types": [
          "function(count: Number, benchmark: Benchmark): ?Promise"
        ],
        "spread": false,
        "optional": true,
        "name": "options.afterEach",
        "description": "setup function. see {@link Suite#after}."
      },
      {
        "nullable": null,
        "types": [
          "function(results: Result[]): ?Promise"
        ],
        "spread": false,
        "optional": true,
        "name": "options.after",
        "description": "setup function. see {@link Suite#after}."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{}",
        "defaultRaw": {},
        "name": "options.benchmarkDefault",
        "description": "default options for {@link Suite#add}."
      }
    ]
  },
  {
    "__docId__": 36,
    "kind": "member",
    "name": "name",
    "memberof": "dist/asyncmark.mjs~Suite",
    "static": false,
    "longname": "dist/asyncmark.mjs~Suite#name",
    "access": "public",
    "description": "Name of this suite.",
    "lineNumber": 420,
    "type": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 37,
    "kind": "member",
    "name": "benchmarkDefault",
    "memberof": "dist/asyncmark.mjs~Suite",
    "static": false,
    "longname": "dist/asyncmark.mjs~Suite#benchmarkDefault",
    "access": "public",
    "description": "Default options for benchmarks in this suite.",
    "lineNumber": 427,
    "type": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 38,
    "kind": "member",
    "name": "benchmarks",
    "memberof": "dist/asyncmark.mjs~Suite",
    "static": false,
    "longname": "dist/asyncmark.mjs~Suite#benchmarks",
    "access": "public",
    "description": "A list of {@link Benchmark}.",
    "lineNumber": 434,
    "type": {
      "nullable": null,
      "types": [
        "Benchmark[]"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 39,
    "kind": "member",
    "name": "parallel",
    "memberof": "dist/asyncmark.mjs~Suite",
    "static": false,
    "longname": "dist/asyncmark.mjs~Suite#parallel",
    "access": "public",
    "description": "Flag for executing each benchmark parallelly.",
    "lineNumber": 441,
    "type": {
      "nullable": null,
      "types": [
        "Boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 44,
    "kind": "method",
    "name": "before",
    "memberof": "dist/asyncmark.mjs~Suite",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "dist/asyncmark.mjs~Suite#before",
    "access": "public",
    "description": "Setup before execute all benchmarks.\n\nAt the time executing this method, `this` is the unique object for the suite.\nSo you can use `this` for storing testing data like a database.\nData of `this` that set in this method will discard after call {@link Suite#after}\n\nIn default, do nothing.",
    "lineNumber": 460,
    "return": {
      "nullable": true,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "{@link Suite} will await if returns {@link Promise}. Resolved value never evaluation."
    },
    "params": []
  },
  {
    "__docId__": 45,
    "kind": "method",
    "name": "beforeEach",
    "memberof": "dist/asyncmark.mjs~Suite",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "dist/asyncmark.mjs~Suite#beforeEach",
    "access": "public",
    "description": "Setup before execute each benchmark.\n\nAt the time executing this method, `this` is the unique object for the test.\nSo you can use `this` for storing testing data like a database.\nData of `this` that set in this method will discard after call {@link Suite#afterEach}\n\nIn default, do nothing.",
    "lineNumber": 476,
    "params": [
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "count",
        "description": "count of done benchmarks in this benchmark."
      },
      {
        "nullable": null,
        "types": [
          "Benchmark"
        ],
        "spread": false,
        "optional": false,
        "name": "benchmark",
        "description": "a {@link Benchmark} instance that will execute."
      }
    ],
    "return": {
      "nullable": true,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "{@link Suite} will await if returns {@link Promise}. Resolved value never evaluation."
    }
  },
  {
    "__docId__": 46,
    "kind": "method",
    "name": "afterEach",
    "memberof": "dist/asyncmark.mjs~Suite",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "dist/asyncmark.mjs~Suite#afterEach",
    "access": "public",
    "description": "Teardown after execute each benchmark.\n\nAt the time executing this method, `this` is the unique object for the test.\nSo you can use `this` for storing testing data like a database.\nData of `this` that set in this method will discard after call this method.\n\nIn default, do nothing.",
    "lineNumber": 493,
    "params": [
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "count",
        "description": "count of done benchmarks in this benchmark."
      },
      {
        "nullable": null,
        "types": [
          "Benchmark"
        ],
        "spread": false,
        "optional": false,
        "name": "benchmark",
        "description": "a {@link Benchmark} instance that executed."
      },
      {
        "nullable": null,
        "types": [
          "Result"
        ],
        "spread": false,
        "optional": false,
        "name": "result",
        "description": "a result of this benchmark."
      }
    ],
    "return": {
      "nullable": true,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "{@link Suite} will await if returns {@link Promise}. Resolved value never evaluation."
    }
  },
  {
    "__docId__": 47,
    "kind": "method",
    "name": "after",
    "memberof": "dist/asyncmark.mjs~Suite",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "dist/asyncmark.mjs~Suite#after",
    "access": "public",
    "description": "Teardown after execute all benchmarks.\n\nAt the time executing this method, `this` is the unique object for the suite.\nSo you can use `this` for storing testing data like a database.\nData of `this` that set in this method will discard after call this method.\n\nIn default, do nothing.",
    "lineNumber": 508,
    "params": [
      {
        "nullable": null,
        "types": [
          "Result[]"
        ],
        "spread": false,
        "optional": false,
        "name": "results",
        "description": "a list of benchmark result."
      }
    ],
    "return": {
      "nullable": true,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "{@link Suite} will await if returns {@link Promise}. Resolved value never evaluation."
    }
  },
  {
    "__docId__": 48,
    "kind": "method",
    "name": "addBenchmark",
    "memberof": "dist/asyncmark.mjs~Suite",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "dist/asyncmark.mjs~Suite#addBenchmark",
    "access": "public",
    "description": "Adding {@link Benchmark} instance into this {@link Suite}.",
    "lineNumber": 517,
    "params": [
      {
        "nullable": null,
        "types": [
          "Benchmark"
        ],
        "spread": false,
        "optional": false,
        "name": "benchmark",
        "description": "the benchmark instance for adding."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Suite"
      ],
      "spread": false,
      "description": "returns this suite for method chain."
    }
  },
  {
    "__docId__": 49,
    "kind": "method",
    "name": "addSuite",
    "memberof": "dist/asyncmark.mjs~Suite",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "dist/asyncmark.mjs~Suite#addSuite",
    "access": "public",
    "description": "Adding child {@link Suite} instance into this {@link Suite}.",
    "lineNumber": 529,
    "params": [
      {
        "nullable": null,
        "types": [
          "Suite"
        ],
        "spread": false,
        "optional": false,
        "name": "suite",
        "description": "the suite instance for adding."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Suite"
      ],
      "spread": false,
      "description": "returns this suite for method chain."
    }
  },
  {
    "__docId__": 50,
    "kind": "method",
    "name": "add",
    "memberof": "dist/asyncmark.mjs~Suite",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "dist/asyncmark.mjs~Suite#add",
    "access": "public",
    "description": "Make new benchmark or suite and adding into this {@link Suite}.",
    "lineNumber": 541,
    "params": [
      {
        "nullable": null,
        "types": [
          "Benchmark",
          "Suite",
          "Object",
          "function"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{}",
        "defaultRaw": {},
        "name": "child",
        "description": "{@link Benchmark}, {@link Suite}, or arguments for {@link Benchmark#constructor}."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Suite"
      ],
      "spread": false,
      "description": "returns this suite for method chain."
    }
  },
  {
    "__docId__": 51,
    "kind": "method",
    "name": "_runParallel",
    "memberof": "dist/asyncmark.mjs~Suite",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "dist/asyncmark.mjs~Suite#_runParallel",
    "access": "private",
    "description": "Execute benchmarks parallelly.",
    "lineNumber": 567,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "context",
        "description": "the context for execute."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Result[]>"
      ],
      "spread": false,
      "description": "result of benchmarks."
    }
  },
  {
    "__docId__": 52,
    "kind": "method",
    "name": "_runSequential",
    "memberof": "dist/asyncmark.mjs~Suite",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "dist/asyncmark.mjs~Suite#_runSequential",
    "access": "private",
    "description": "Execute benchmarks sequential.",
    "lineNumber": 592,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "context",
        "description": "the context for execute."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Result[]>"
      ],
      "spread": false,
      "description": "result of benchmarks."
    }
  },
  {
    "__docId__": 53,
    "kind": "method",
    "name": "run",
    "memberof": "dist/asyncmark.mjs~Suite",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "dist/asyncmark.mjs~Suite#run",
    "access": "public",
    "description": "Execute benchmarks in this suite.\n\nAll benchmarks will execute parallel if enabled {@link Suite#parallel} option.\nElse do execute sequentially by added order.",
    "lineNumber": 620,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{}",
        "defaultRaw": {},
        "name": "context",
        "description": "the `this` for each benchmarking functions. `__proto__` will override with this instance."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Result[]>"
      ],
      "spread": false,
      "description": "An array of {@link Result}s."
    }
  },
  {
    "kind": "index",
    "content": "AsyncMark\n=========\n\nA benchmarking library for javascript that supports Promise.\n\n[![NPM](https://nodei.co/npm/asyncmark.png)](https://nodei.co/npm/asyncmark/)\n\n[![Build Status](https://travis-ci.org/macrat/AsyncMark.svg?branch=master)](https://travis-ci.org/macrat/AsyncMark)\n[![Test Coverage](https://api.codeclimate.com/v1/badges/d15df6e95751f31ab637/test_coverage)](https://codeclimate.com/github/macrat/AsyncMark/test_coverage)\n[![Maintainability](https://api.codeclimate.com/v1/badges/d15df6e95751f31ab637/maintainability)](https://codeclimate.com/github/macrat/AsyncMark/maintainability)\n[![license](https://img.shields.io/github/license/macrat/AsyncMark.svg)](https://github.com/macrat/AsyncMark/blob/master/LICENSE)\n[![document](https://macrat.github.io/AsyncMark/badge.svg)](https://macrat.github.io/AsyncMark/)\n\n## be simple\n``` javascript\nimport Benchmark from 'asyncmark';\n\n\nnew Benchmark(function() {\n    return new Promise((resolve, reject) => {\n        setTimeout(resolve, 100)\n    });\n}).run().catch(console.error);\n```\n\n## be customizable\n``` javascript\nimport {Suite} from 'asyncmark';\n\n\nconst suite = new Suite({\n    name: 'ways to find a character',\n    beforeEach() {\n        this.text = 'hello world';\n    },\n    parallel: true,\n});\n\nsuite.add(function() {\n    /o/.test(this.text);\n});\n\nsuite.add({\n    name: 'String#indexOf',\n    before() {\n        console.log('starting String#indexOf...');\n    },\n    fun() {\n        this.text.indexOf('o') > -1;\n    },\n});\n\nsuite.add(new Benchmark({\n    name: 'String#match',\n    fun() {\n        Boolean(this.text.match(/o/));\n    },\n    after(result) {\n        console.log('String#match is done! ' + result);\n    },\n}));\n\nsuite.run()\n    .then(results => {\n        let min = results[0];\n        results.forEach(x => {\n            if (min.average > x.average) {\n                min = x;\n            }\n        });\n        console.log(min.name + ' is best way!');\n    }).\n    catch(err => console.error(err));\n```\n\n## installation\n### Node.js\n``` shell\n$ npm install asyncmark\n```\n\n#### ES6\n``` javascript\nimport Benchmark, {Suite} from 'asyncmark';\n```\n\n#### CommonJS\n``` javascript\nconst AsyncMark = require('asyncmark');\n\nconst Benchmark = AsyncMark.Benchmark;\nconst Suite = AsyncMark.Suite;\n```\n\n### Browser\n``` html\n<script src=\"https://unpkg.com/asyncmark\"></script>\n<script>\nconst Benchmark = AsyncMark.Benchmark;\nconst Suite = AsyncMark.Suite;\n</script>\n```\n",
    "longname": "/home/ena/AsyncMark/README.md",
    "name": "./README.md",
    "static": true,
    "access": "public"
  },
  {
    "__docId__": 54,
    "kind": "testFile",
    "name": "test/benchmark.js",
    "content": "import assert from 'power-assert';\n\nimport Benchmark, {Benchmark as Bench2, Result} from '../src';\n\n\n/**\n * @test {Benchmark}\n */\ndescribe('Benchmark', function() {\n    it('module exports', function() {\n        assert(Benchmark === Bench2);\n    });\n\n    /**\n     * @test {Benchmark#constructor}\n     */\n    describe('#constructor', function() {\n        it('default values', function() {\n            const b = new Benchmark();\n\n            assert(b.name === 'unnamed');\n            assert(b.targetErrorRate === 0.1);\n            assert(b.maxNumber === 10000);\n            assert(b.minNumber === 30);\n            assert(b.number === null);\n        });\n\n        it('function argument', function() {\n            let called = false;\n            const f = function() {\n                called = true;\n            }\n            const b = new Benchmark(f);\n\n            assert(b.fun === f);\n\n            assert(called === false);\n            b.fun();\n            assert(called === true);\n        });\n\n        describe('object argument', function() {\n            it('with auto number', function() {\n                const conf = {\n                    name: 'test name',\n                    targetErrorRate: 0.2,\n                    maxNumber: 100,\n                    minNumber: 10,\n                };\n                const b = new Benchmark(conf);\n\n                assert(b.name === conf.name);\n                assert(b.targetErrorRate === conf.targetErrorRate);\n                assert(b.maxNumber === conf.maxNumber);\n                assert(b.minNumber === conf.minNumber);\n            });\n\n            it('with specify number', function() {\n                const conf = {\n                    name: 'test name',\n                    number: 42,\n                };\n                const b = new Benchmark(conf);\n\n                assert(b.name === conf.name);\n                assert(b.number === conf.number);\n            });\n\n            it('functions', function() {\n                const called = {\n                    before: false,\n                    beforeEach: false,\n                    fun: false,\n                    afterEach: false,\n                    after: false,\n                };\n                const conf = {\n                    name: 'test name',\n                    number: 42,\n                    before() {\n                        called.before = true;\n                    },\n                    beforeEach() {\n                        called.beforeEach = true;\n                    },\n                    fun() {\n                        called.fun = true;\n                    },\n                    afterEach() {\n                        called.afterEach = true;\n                    },\n                    after() {\n                        called.after = true;\n                    },\n                };\n                const b = new Benchmark(conf);\n\n                assert(b.name === conf.name);\n                assert(b.number === conf.number);\n\n                assert(called.before === false);\n                b.before();\n                assert(called.before === true);\n\n                assert(called.beforeEach === false);\n                b.beforeEach();\n                assert(called.beforeEach === true);\n\n                assert(called.fun === false);\n                b.fun();\n                assert(called.fun === true);\n\n                assert(called.afterEach === false);\n                b.afterEach();\n                assert(called.afterEach === true);\n\n                assert(called.after === false);\n                b.after();\n                assert(called.after === true);\n            });\n        });\n    });\n\n    /**\n     * @test {Benchmark#fun}\n     */\n    describe('#fun', function() {\n        it('default behavior', async function() {\n            const b = new Benchmark();\n\n            const err = await b.fun().then(() => null).catch(e => e);\n            assert(err !== null, 'excepted error but not throwed');\n            assert(err.message === 'target function is not defined');\n        });\n    });\n\n    /**\n     * @test {Benchmark#after}\n     */\n    describe('#after', function() {\n        it('default behavior', async function() {\n            const l = console.log;\n            const messages = [];\n            console.log = function() {\n                messages.push([...arguments].map(x => String(x)).join(' '));\n            }\n\n            try {\n                const b = new Benchmark();\n                const r = new Result('after_test', [1, 2, 3])\n\n                await b.after(r);\n\n                assert.deepStrictEqual(messages, [r.toString()]);\n            } finally {\n                console.log = l;\n            }\n        });\n    });\n\n    /**\n     * @test {Benchmark#run}\n     */\n    describe('#run', function() {\n        it('call methods order', async function() {\n            const callLog = [];\n\n            const conf = {\n                number: 2,\n                before() {\n                    callLog.push('before');\n                },\n                beforeEach() {\n                    callLog.push('beforeEach');\n                },\n                fun() {\n                    callLog.push('fun');\n                },\n                afterEach() {\n                    callLog.push('afterEach');\n                },\n                after() {\n                    callLog.push('after');\n                },\n            };\n            const b = new Benchmark(conf);\n\n            const l = console.log;\n            const messages = [];\n            console.log = function() {\n                messages.push([...arguments].map(x => String(x)).join(' '));\n            }\n\n            try {\n                await b.run();\n\n                assert.deepStrictEqual(callLog, [\n                    'before',\n                    'beforeEach',\n                    'fun',\n                    'afterEach',\n                    'beforeEach',\n                    'fun',\n                    'afterEach',\n                    'after',\n                ]);\n                assert.deepStrictEqual(messages, []);\n            } finally {\n                console.log = l;\n            }\n        });\n\n        it('context handling', async function() {\n            const conf = {\n                number: 2,\n                before() {\n                    assert(this.inOuter === undefined);\n                    assert(this.inInner === undefined);\n                    assert(this.inFunc === undefined);\n                    assert(this.outInner === undefined);\n                    assert(this.outOuter === undefined);\n\n                    this.inOuter = 123;\n                },\n                beforeEach() {\n                    assert(this.inOuter === 123);\n                    assert(this.inInner === undefined);\n                    assert(this.inFunc === undefined);\n                    assert(this.outInner === undefined);\n                    assert(this.outOuter === undefined);\n\n                    this.inInner = 'abc';\n                },\n                fun() {\n                    assert(this.inOuter === 123);\n                    assert(this.inInner === 'abc');\n                    assert(this.inFunc === undefined);\n                    assert(this.outInner === undefined);\n                    assert(this.outOuter === undefined);\n\n                    this.inFunc = true;\n                },\n                afterEach() {\n                    assert(this.inOuter === 123);\n                    assert(this.inInner === 'abc');\n                    assert(this.inFunc === true);\n                    assert(this.outInner === undefined);\n                    assert(this.outOuter === undefined);\n\n                    this.outInner = 'cba';\n                },\n                after() {\n                    assert(this.inOuter === 123);\n                    assert(this.inInner === undefined);\n                    assert(this.inFunc === undefined);\n                    assert(this.outInner === undefined);\n                    assert(this.outOuter === undefined);\n\n                    this.outOuter = 321;\n                },\n            };\n            const b = new Benchmark(conf);\n\n            const l = console.log;\n            const messages = [];\n            console.log = function() {\n                messages.push([...arguments].map(x => String(x)).join(' '));\n            }\n\n            try {\n                await b.run();\n                assert.deepStrictEqual(messages, []);\n            } finally {\n                console.log = l;\n            }\n        });\n\n        it('arguments for methods', async function() {\n            const beforeCounts = [];\n            const afterCounts = [];\n\n            const b = new Benchmark({\n                number: 2,\n                before() {\n                    assert(arguments.length === 0);\n                },\n                beforeEach(count) {\n                    assert(arguments.length === 1);\n\n                    assert(typeof count === 'number');\n                    beforeCounts.push(count);\n                },\n                fun() {\n                    assert(arguments.length === 0);\n                },\n                afterEach(count, msec) {\n                    assert(arguments.length === 2);\n\n                    assert(typeof msec === 'number');\n                    assert(msec < 1);\n\n                    assert(typeof count === 'number');\n                    afterCounts.push(count);\n                },\n                after(result) {\n                    assert(arguments.length === 1);\n\n                    assert(result instanceof Result);\n                    assert(result.msecs.length === 2)\n                },\n            });\n\n            const result = await b.run();\n            assert(result instanceof Result);\n            assert(result.msecs.length === 2);\n\n            assert.deepStrictEqual(beforeCounts, [0, 1]);\n            assert.deepStrictEqual(afterCounts, [0, 1]);\n        });\n\n        it('timer', async function() {\n            const r100 = await new Benchmark({\n                number: 3,\n                fun() {\n                    return new Promise((resolve, reject) => setTimeout(resolve, 100));\n                },\n                after() {}\n            }).run();\n            assert(Math.abs(r100.average - 100) <= 3);\n\n            const r42 = await new Benchmark({\n                number: 3,\n                fun() {\n                    return new Promise((resolve, reject) => setTimeout(resolve, 42));\n                },\n                after() {}\n            }).run();\n            assert(Math.abs(r42.average - 42) <= 3);\n        });\n    });\n});\n",
    "static": true,
    "longname": "/home/ena/AsyncMark/test/benchmark.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 55,
    "kind": "test",
    "name": "describe0",
    "testId": 0,
    "memberof": "test/benchmark.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/benchmark.js~describe0",
    "access": null,
    "description": "Benchmark",
    "lineNumber": 9,
    "testTargets": [
      "Benchmark"
    ]
  },
  {
    "__docId__": 56,
    "kind": "test",
    "name": "it1",
    "testId": 1,
    "memberof": "test/benchmark.js~describe0",
    "testDepth": 1,
    "static": true,
    "longname": "test/benchmark.js~describe0.it1",
    "access": null,
    "description": "module exports",
    "lineNumber": 10
  },
  {
    "__docId__": 57,
    "kind": "test",
    "name": "describe2",
    "testId": 2,
    "memberof": "test/benchmark.js~describe0",
    "testDepth": 1,
    "static": true,
    "longname": "test/benchmark.js~describe0.describe2",
    "access": null,
    "description": "#constructor",
    "lineNumber": 17,
    "testTargets": [
      "Benchmark#constructor"
    ]
  },
  {
    "__docId__": 58,
    "kind": "test",
    "name": "it3",
    "testId": 3,
    "memberof": "test/benchmark.js~describe0.describe2",
    "testDepth": 2,
    "static": true,
    "longname": "test/benchmark.js~describe0.describe2.it3",
    "access": null,
    "description": "default values",
    "lineNumber": 18
  },
  {
    "__docId__": 59,
    "kind": "test",
    "name": "it4",
    "testId": 4,
    "memberof": "test/benchmark.js~describe0.describe2",
    "testDepth": 2,
    "static": true,
    "longname": "test/benchmark.js~describe0.describe2.it4",
    "access": null,
    "description": "function argument",
    "lineNumber": 28
  },
  {
    "__docId__": 60,
    "kind": "test",
    "name": "describe5",
    "testId": 5,
    "memberof": "test/benchmark.js~describe0.describe2",
    "testDepth": 2,
    "static": true,
    "longname": "test/benchmark.js~describe0.describe2.describe5",
    "access": null,
    "description": "object argument",
    "lineNumber": 42
  },
  {
    "__docId__": 61,
    "kind": "test",
    "name": "it6",
    "testId": 6,
    "memberof": "test/benchmark.js~describe0.describe2.describe5",
    "testDepth": 3,
    "static": true,
    "longname": "test/benchmark.js~describe0.describe2.describe5.it6",
    "access": null,
    "description": "with auto number",
    "lineNumber": 43
  },
  {
    "__docId__": 62,
    "kind": "test",
    "name": "it7",
    "testId": 7,
    "memberof": "test/benchmark.js~describe0.describe2.describe5",
    "testDepth": 3,
    "static": true,
    "longname": "test/benchmark.js~describe0.describe2.describe5.it7",
    "access": null,
    "description": "with specify number",
    "lineNumber": 58
  },
  {
    "__docId__": 63,
    "kind": "test",
    "name": "it8",
    "testId": 8,
    "memberof": "test/benchmark.js~describe0.describe2.describe5",
    "testDepth": 3,
    "static": true,
    "longname": "test/benchmark.js~describe0.describe2.describe5.it8",
    "access": null,
    "description": "functions",
    "lineNumber": 69
  },
  {
    "__docId__": 64,
    "kind": "test",
    "name": "describe9",
    "testId": 9,
    "memberof": "test/benchmark.js~describe0",
    "testDepth": 1,
    "static": true,
    "longname": "test/benchmark.js~describe0.describe9",
    "access": null,
    "description": "#fun",
    "lineNumber": 127,
    "testTargets": [
      "Benchmark#fun"
    ]
  },
  {
    "__docId__": 65,
    "kind": "test",
    "name": "it10",
    "testId": 10,
    "memberof": "test/benchmark.js~describe0.describe9",
    "testDepth": 2,
    "static": true,
    "longname": "test/benchmark.js~describe0.describe9.it10",
    "access": null,
    "description": "default behavior",
    "lineNumber": 128
  },
  {
    "__docId__": 66,
    "kind": "test",
    "name": "describe11",
    "testId": 11,
    "memberof": "test/benchmark.js~describe0",
    "testDepth": 1,
    "static": true,
    "longname": "test/benchmark.js~describe0.describe11",
    "access": null,
    "description": "#after",
    "lineNumber": 140,
    "testTargets": [
      "Benchmark#after"
    ]
  },
  {
    "__docId__": 67,
    "kind": "test",
    "name": "it12",
    "testId": 12,
    "memberof": "test/benchmark.js~describe0.describe11",
    "testDepth": 2,
    "static": true,
    "longname": "test/benchmark.js~describe0.describe11.it12",
    "access": null,
    "description": "default behavior",
    "lineNumber": 141
  },
  {
    "__docId__": 68,
    "kind": "test",
    "name": "describe13",
    "testId": 13,
    "memberof": "test/benchmark.js~describe0",
    "testDepth": 1,
    "static": true,
    "longname": "test/benchmark.js~describe0.describe13",
    "access": null,
    "description": "#run",
    "lineNumber": 164,
    "testTargets": [
      "Benchmark#run"
    ]
  },
  {
    "__docId__": 69,
    "kind": "test",
    "name": "it14",
    "testId": 14,
    "memberof": "test/benchmark.js~describe0.describe13",
    "testDepth": 2,
    "static": true,
    "longname": "test/benchmark.js~describe0.describe13.it14",
    "access": null,
    "description": "call methods order",
    "lineNumber": 165
  },
  {
    "__docId__": 70,
    "kind": "test",
    "name": "it15",
    "testId": 15,
    "memberof": "test/benchmark.js~describe0.describe13",
    "testDepth": 2,
    "static": true,
    "longname": "test/benchmark.js~describe0.describe13.it15",
    "access": null,
    "description": "context handling",
    "lineNumber": 213
  },
  {
    "__docId__": 71,
    "kind": "test",
    "name": "it16",
    "testId": 16,
    "memberof": "test/benchmark.js~describe0.describe13",
    "testDepth": 2,
    "static": true,
    "longname": "test/benchmark.js~describe0.describe13.it16",
    "access": null,
    "description": "arguments for methods",
    "lineNumber": 278
  },
  {
    "__docId__": 72,
    "kind": "test",
    "name": "it17",
    "testId": 17,
    "memberof": "test/benchmark.js~describe0.describe13",
    "testDepth": 2,
    "static": true,
    "longname": "test/benchmark.js~describe0.describe13.it17",
    "access": null,
    "description": "timer",
    "lineNumber": 321
  },
  {
    "__docId__": 73,
    "kind": "testFile",
    "name": "test/result.js",
    "content": "import assert from 'power-assert';\n\nimport {Result} from '../src';\n\n\n/**\n * @test {Result}\n */\ndescribe('Result', function() {\n    /**\n     * @test {Result#total}\n     */\n    it('#total', function() {\n        assert(new Result('test', [10, 20, 30]).total === 60);\n        assert(new Result('test', [11, 22, 33]).total === 66);\n    });\n\n    /**\n     * @test {Result#average}\n     */\n    it('#average', function() {\n        assert(new Result('test', [10, 20, 30]).average === 20);\n        assert(new Result('test', [11, 22, 33]).average === 22);\n    });\n\n    /**\n     * @test {Result#variance}\n     */\n    it('#variance', function() {\n        assert(new Result('test', [10, 20, 30]).variance === 100);\n        assert(new Result('test', [11, 22, 33]).variance === 121);\n    });\n\n    /**\n     * @test {Result#std}\n     */\n    it('#std', function() {\n        assert(new Result('test', [10, 20, 30]).std === 10);\n        assert(new Result('test', [11, 22, 33]).std === 11);\n    });\n\n    /**\n     * @test {Result#std}\n     */\n    it('#sem', function() {\n        assert(Math.abs(new Result('test', [10, 20, 30]).sem - 5.7735) < 0.001);\n        assert(Math.abs(new Result('test', [11, 22, 33]).sem - 6.3509) < 0.001);\n    });\n\n    /**\n     * @test {Result#errorRange}\n     */\n    it('#errorRange', function() {\n        assert(Math.abs(new Result('test', [10, 20, 30]).errorRange - 11.3161) < 0.001);\n        assert(Math.abs(new Result('test', [11, 22, 33]).errorRange - 12.4477) < 0.001);\n    });\n\n    /**\n     * @test {Result#errorRate}\n     */\n    it('#errorRate', function() {\n        assert(Math.abs(new Result('test', [10, 20, 30]).errorRate - 0.5658) < 0.001);\n        assert(Math.abs(new Result('test', [11, 22, 33]).errorRate - 0.5658) < 0.001);\n    });\n\n    /**\n     * @test {Result#opsPerSec}\n     */\n    it('#opsPerSec', function() {\n        assert(new Result('test', [1]).opsPerSec === 1000);\n        assert(new Result('test', [200]).opsPerSec === 5);\n    });\n\n    /**\n     * @test {Result#toString}\n     */\n    it('#toString', function() {\n        assert(String(new Result('test', [10, 20, 30])) === 'test: 50ops/sec 20msec/op +-11.3161msec/op (56.58%) / 3 times tried');\n        assert(String(new Result('test', [1.234567, 2.345678])) === 'test: 558.621ops/sec 1.7901msec/op +-1.0889msec/op (60.83%) / 2 times tried');\n    });\n});\n",
    "static": true,
    "longname": "/home/ena/AsyncMark/test/result.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 74,
    "kind": "test",
    "name": "describe18",
    "testId": 18,
    "memberof": "test/result.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/result.js~describe18",
    "access": null,
    "description": "Result",
    "lineNumber": 9,
    "testTargets": [
      "Result"
    ]
  },
  {
    "__docId__": 75,
    "kind": "test",
    "name": "it19",
    "testId": 19,
    "memberof": "test/result.js~describe18",
    "testDepth": 1,
    "static": true,
    "longname": "test/result.js~describe18.it19",
    "access": null,
    "description": "#total",
    "lineNumber": 13,
    "testTargets": [
      "Result#total"
    ]
  },
  {
    "__docId__": 76,
    "kind": "test",
    "name": "it20",
    "testId": 20,
    "memberof": "test/result.js~describe18",
    "testDepth": 1,
    "static": true,
    "longname": "test/result.js~describe18.it20",
    "access": null,
    "description": "#average",
    "lineNumber": 21,
    "testTargets": [
      "Result#average"
    ]
  },
  {
    "__docId__": 77,
    "kind": "test",
    "name": "it21",
    "testId": 21,
    "memberof": "test/result.js~describe18",
    "testDepth": 1,
    "static": true,
    "longname": "test/result.js~describe18.it21",
    "access": null,
    "description": "#variance",
    "lineNumber": 29,
    "testTargets": [
      "Result#variance"
    ]
  },
  {
    "__docId__": 78,
    "kind": "test",
    "name": "it22",
    "testId": 22,
    "memberof": "test/result.js~describe18",
    "testDepth": 1,
    "static": true,
    "longname": "test/result.js~describe18.it22",
    "access": null,
    "description": "#std",
    "lineNumber": 37,
    "testTargets": [
      "Result#std"
    ]
  },
  {
    "__docId__": 79,
    "kind": "test",
    "name": "it23",
    "testId": 23,
    "memberof": "test/result.js~describe18",
    "testDepth": 1,
    "static": true,
    "longname": "test/result.js~describe18.it23",
    "access": null,
    "description": "#sem",
    "lineNumber": 45,
    "testTargets": [
      "Result#std"
    ]
  },
  {
    "__docId__": 80,
    "kind": "test",
    "name": "it24",
    "testId": 24,
    "memberof": "test/result.js~describe18",
    "testDepth": 1,
    "static": true,
    "longname": "test/result.js~describe18.it24",
    "access": null,
    "description": "#errorRange",
    "lineNumber": 53,
    "testTargets": [
      "Result#errorRange"
    ]
  },
  {
    "__docId__": 81,
    "kind": "test",
    "name": "it25",
    "testId": 25,
    "memberof": "test/result.js~describe18",
    "testDepth": 1,
    "static": true,
    "longname": "test/result.js~describe18.it25",
    "access": null,
    "description": "#errorRate",
    "lineNumber": 61,
    "testTargets": [
      "Result#errorRate"
    ]
  },
  {
    "__docId__": 82,
    "kind": "test",
    "name": "it26",
    "testId": 26,
    "memberof": "test/result.js~describe18",
    "testDepth": 1,
    "static": true,
    "longname": "test/result.js~describe18.it26",
    "access": null,
    "description": "#opsPerSec",
    "lineNumber": 69,
    "testTargets": [
      "Result#opsPerSec"
    ]
  },
  {
    "__docId__": 83,
    "kind": "test",
    "name": "it27",
    "testId": 27,
    "memberof": "test/result.js~describe18",
    "testDepth": 1,
    "static": true,
    "longname": "test/result.js~describe18.it27",
    "access": null,
    "description": "#toString",
    "lineNumber": 77,
    "testTargets": [
      "Result#toString"
    ]
  },
  {
    "__docId__": 84,
    "kind": "testFile",
    "name": "test/suite.js",
    "content": "import assert from 'power-assert';\n\nimport Benchmark, {Suite, Result} from '../src';\n\n\n/**\n * @test {Suite}\n */\ndescribe('Suite', function() {\n    describe('#constructor', function() {\n        it('default values', function() {\n            const s = new Suite();\n\n            assert(s.name === 'unnamed');\n            assert(s.parallel === false);\n            assert.deepStrictEqual(s.benchmarkDefault, {});\n        });\n\n        it('options', function() {\n            const conf = {\n                name: 'foo',\n                parallel: true,\n                benchmarkDefault: {\n                    name: 'bar',\n                },\n            };\n            const s = new Suite(conf);\n\n            assert(s.name === 'foo');\n            assert(s.parallel === true);\n            assert.deepStrictEqual(s.benchmarkDefault, {name: 'bar'});\n        });\n\n        it('functions', function() {\n            const called = {\n                before: false,\n                beforeEach: false,\n                afterEach: false,\n                after: false,\n            };\n            const s = new Suite({\n                before() {\n                    called.before = true;\n                },\n                beforeEach() {\n                    called.beforeEach = true;\n                },\n                fun() {\n                    called.fun = true;\n                },\n                afterEach() {\n                    called.afterEach = true;\n                },\n                after() {\n                    called.after = true;\n                },\n            });\n\n            assert(called.before === false);\n            s.before();\n            assert(called.before === true);\n\n            assert(called.beforeEach === false);\n            s.beforeEach();\n            assert(called.beforeEach === true);\n\n            assert(called.afterEach === false);\n            s.afterEach();\n            assert(called.afterEach === true);\n\n            assert(called.after === false);\n            s.after();\n            assert(called.after === true);\n        });\n    });\n\n    /**\n     * @test {Suite#addBenchmark}\n     */\n    it('#addBenchmark', function() {\n        const s = new Suite();\n        const b1 = new Benchmark({name: 'a'});\n        const b2 = new Benchmark({name: 'b'});\n\n        assert.deepStrictEqual(s.benchmarks, []);\n        s.addBenchmark(b1);\n        assert.deepStrictEqual(s.benchmarks, [b1]);\n        s.addBenchmark(b2);\n        assert.deepStrictEqual(s.benchmarks, [b1, b2]);\n\n        assert(s.benchmarks[0].name === 'a');\n        assert(s.benchmarks[1].name === 'b');\n    });\n\n    /**\n     * @test {Suite#addSuite}\n     */\n    it('#addSuite', function() {\n        const p = new Suite();\n        const c1 = new Suite();\n        const c2 = new Suite();\n\n        assert(p !== c1);\n        assert(p !== c2);\n        assert(c1 !== c2);\n\n        assert.deepStrictEqual(p.benchmarks, []);\n        p.addBenchmark(c1);\n        assert.deepStrictEqual(p.benchmarks, [c1]);\n        p.addBenchmark(c2);\n        assert.deepStrictEqual(p.benchmarks, [c1, c2]);\n    });\n\n    /**\n     * @test {Suite#add}\n     */\n    describe('#add', function() {\n        it('Benchmark', function() {\n            const s = new Suite();\n            const b = new Benchmark({name: 'foobar'});\n\n            assert.deepStrictEqual(s.benchmarks, []);\n            s.add(b);\n\n            assert.deepStrictEqual(s.benchmarks, [b]);\n            assert(s.benchmarks[0].name === 'foobar');\n        });\n\n        it('Suite', function() {\n            const p = new Suite();\n            const c = new Suite();\n\n            assert(p !== c);\n            assert.deepStrictEqual(p.benchmarks, []);\n\n            p.add(c);\n\n            assert.deepStrictEqual(p.benchmarks, [c]);\n            assert.deepStrictEqual(c.benchmarks, []);\n        });\n\n        it('function', async function() {\n            const called = {\n                fun: false,\n                after: false,\n            };\n            const fun = function() {\n                called.fun = true;\n            };\n            const s = new Suite({\n                benchmarkDefault: {\n                    after() {\n                        called.after = true;\n                    },\n                },\n            });\n\n            assert.deepStrictEqual(s.benchmarks, []);\n            s.add(fun);\n            assert(s.benchmarks.length === 1);\n\n            assert(called.fun === false);\n            await s.benchmarks[0].fun();\n            assert(called.fun === true);\n\n            assert(called.after === false);\n            await s.benchmarks[0].after();\n            assert(called.after === true);\n        });\n\n        it('function with override default', async function() {\n            const called = {\n                original: false,\n                overrided: false,\n            };\n            const s = new Suite({\n                benchmarkDefault: {\n                    fun() {\n                        called.original = true;\n                    },\n                },\n            });\n\n            const conf = {\n                fun() {\n                    called.overrided = true;\n                },\n            };\n\n            assert.deepStrictEqual(s.benchmarks, []);\n            s.add(conf);\n            assert(s.benchmarks.length === 1);\n\n            assert(called.original === false);\n            assert(called.overrided === false);\n            await s.benchmarks[0].fun();\n            assert(called.original === false);\n            assert(called.overrided === true);\n        });\n\n        it('object', async function() {\n            const called = {\n                fun: false,\n                after: false,\n            };\n            const s = new Suite({\n                benchmarkDefault: {\n                    after() {\n                        called.after = true;\n                    },\n                },\n            });\n\n            const conf = {\n                fun() {\n                    called.fun = true;\n                },\n            };\n\n            assert.deepStrictEqual(s.benchmarks, []);\n            s.add(conf);\n            assert(s.benchmarks.length === 1);\n\n            assert(called.fun === false);\n            await s.benchmarks[0].fun();\n            assert(called.fun === true);\n\n            assert(called.after === false);\n            await s.benchmarks[0].after();\n            assert(called.after === true);\n        });\n\n        it('object with override default', async function() {\n            const called = {\n                original: false,\n                overrided: false,\n            };\n            const s = new Suite({\n                benchmarkDefault: {\n                    after() {\n                        called.original = true;\n                    },\n                },\n            });\n\n            const conf = {\n                after() {\n                    called.overrided = true;\n                },\n            };\n\n            assert.deepStrictEqual(s.benchmarks, []);\n            s.add(conf);\n            assert(s.benchmarks.length === 1);\n\n            assert(called.original === false);\n            assert(called.overrided === false);\n            await s.benchmarks[0].after();\n            assert(called.original === false);\n            assert(called.overrided === true);\n        });\n    });\n\n    /**\n     * @test {Suite#run}\n     */\n    describe('#run', function() {\n        describe('call methods order', function() {\n            it('empty tests', async function() {\n                const callLog = [];\n\n                const s = new Suite({\n                    before() {\n                        callLog.push('before');\n                    },\n                    beforeEach() {\n                        callLog.push('beforeEach');\n                    },\n                    afterEach() {\n                        callLog.push('afterEach');\n                    },\n                    after() {\n                        callLog.push('after');\n                    },\n                });\n\n                assert.deepStrictEqual(callLog, []);\n\n                await s.run();\n\n                assert.deepStrictEqual(callLog, [\n                    'before',\n                    'after',\n                ]);\n            });\n\n            it('empty tests (enabled parallel)', async function() {\n                const callLog = [];\n\n                const s = new Suite({\n                    before() {\n                        callLog.push('before');\n                    },\n                    beforeEach() {\n                        callLog.push('beforeEach');\n                    },\n                    afterEach() {\n                        callLog.push('afterEach');\n                    },\n                    after() {\n                        callLog.push('after');\n                    },\n                    parallel: true,\n                });\n\n                assert.deepStrictEqual(callLog, []);\n\n                await s.run();\n\n                assert.deepStrictEqual(callLog, [\n                    'before',\n                    'after',\n                ]);\n            });\n\n            it('with test', async function() {\n                const callLog = [];\n\n                const s = new Suite({\n                    before() {\n                        callLog.push('before');\n                    },\n                    beforeEach() {\n                        callLog.push('beforeEach');\n                    },\n                    afterEach() {\n                        callLog.push('afterEach');\n                    },\n                    after() {\n                        callLog.push('after');\n                    },\n                    benchmarkDefault: {\n                        after() {},\n                    },\n                });\n\n                s.add({\n                    number: 2,\n                    fun() {\n                        callLog.push('bench1');\n                    },\n                });\n\n                s.add({\n                    number: 3,\n                    fun() {\n                        callLog.push('bench2');\n                    },\n                });\n\n                assert.deepStrictEqual(callLog, []);\n\n                await s.run();\n\n                assert.deepStrictEqual(callLog, [\n                    'before',\n                    'beforeEach',\n                    'bench1',\n                    'bench1',\n                    'afterEach',\n                    'beforeEach',\n                    'bench2',\n                    'bench2',\n                    'bench2',\n                    'afterEach',\n                    'after',\n                ]);\n            });\n\n            it('with test (enabled parallel)', async function() {\n                const callLog = [];\n\n                const s = new Suite({\n                    before() {\n                        callLog.push('before');\n                    },\n                    beforeEach() {\n                        callLog.push('beforeEach');\n                    },\n                    afterEach() {\n                        callLog.push('afterEach');\n                    },\n                    after() {\n                        callLog.push('after');\n                    },\n                    benchmarkDefault: {\n                        after() {},\n                    },\n                    parallel: true,\n                });\n\n                s.add({\n                    number: 2,\n                    fun() {\n                        callLog.push('bench1');\n                    },\n                });\n\n                s.add({\n                    number: 3,\n                    fun() {\n                        callLog.push('bench2');\n                    },\n                });\n\n                assert.deepStrictEqual(callLog, []);\n\n                await s.run();\n\n                assert(callLog.length === 11);\n\n                assert(callLog[0] === 'before');\n                assert(callLog[1] === 'beforeEach');\n                assert(callLog[callLog.length - 2] === 'afterEach');\n                assert(callLog[callLog.length - 1] === 'after');\n\n                assert(callLog.filter(x => x === 'bench1').length === 2);\n                assert(callLog.filter(x => x === 'bench2').length === 3);\n                assert(callLog.filter(x => x === 'beforeEach').length === 2);\n                assert(callLog.filter(x => x === 'afterEach').length === 2);\n            });\n        });\n\n        const contextTest = async function(options) {\n            options.__proto__ = {\n                before() {\n                    assert(this.inOuter === undefined);\n                    assert(this.inInner === undefined);\n                    assert(this.inBench === undefined);\n                    assert(this.outInner === undefined);\n                    assert(this.outOuter === undefined);\n\n                    this.inOuter = 123;\n                },\n                beforeEach() {\n                    assert(this.inOuter === 123);\n                    assert(this.inInner === undefined);\n                    assert(this.inBench === undefined);\n                    assert(this.outInner === undefined);\n                    assert(this.outOuter === undefined);\n\n                    this.inInner = 'abc';\n                },\n                afterEach() {\n                    assert(this.inOuter === 123);\n                    assert(this.inInner === 'abc');\n                    assert(this.inBench === undefined);\n                    assert(this.outInner === undefined);\n                    assert(this.outOuter === undefined);\n\n                    this.outInner = 'cba';\n                },\n                after() {\n                    assert(this.inOuter === 123);\n                    assert(this.inInner === undefined);\n                    assert(this.inBench === undefined);\n                    assert(this.outInner === undefined);\n                    assert(this.outOuter === undefined);\n\n                    this.outOuter = 321;\n                },\n                benchmarkDefault: {\n                    fun() {},\n                },\n            };\n\n            const s = new Suite(options);\n\n            s.add({\n                number: 2,\n                before() {\n                    assert(this.inOuter === 123);\n                    assert(this.inInner === 'abc');\n                    assert(this.inBench === undefined);\n                    assert(this.outInner === undefined);\n                    assert(this.outOuter === undefined);\n\n                    this.inBench = 42;\n                },\n                after() {\n                    assert(this.inOuter === 123);\n                    assert(this.inInner === 'abc');\n                    assert(this.inBench === 42);\n                    assert(this.outInner === undefined);\n                    assert(this.outOuter === undefined);\n                },\n            });\n\n            s.add({\n                number: 3,\n                before() {\n                    assert(this.inOuter === 123);\n                    assert(this.inInner === 'abc');\n                    assert(this.inBench === undefined);\n                    assert(this.outInner === undefined);\n                    assert(this.outOuter === undefined);\n\n                    this.inBench = 24;\n                },\n                after() {\n                    assert(this.inOuter === 123);\n                    assert(this.inInner === 'abc');\n                    assert(this.inBench === 24);\n                    assert(this.outInner === undefined);\n                    assert(this.outOuter === undefined);\n                },\n            });\n\n            await s.run();\n        };\n\n        it('context handling', function() {\n            return contextTest({parallel: false});\n        });\n\n        it('context handling (enabled parallel)', function() {\n            return contextTest({parallel: true});\n        });\n\n        const argumentsTest = async function(options) {\n            const beforeCounts = [];\n            const afterCounts = [];\n\n            options.__proto__ = {\n                before() {\n                    assert(arguments.length === 0);\n                },\n                beforeEach(count, benchmark) {\n                    assert(arguments.length === 2);\n\n                    assert(typeof count === 'number');\n                    beforeCounts.push(count);\n\n                    assert(benchmark instanceof Benchmark);\n                },\n                fun() {\n                    assert(arguments.length === 0);\n                },\n                afterEach(count, benchmark, result) {\n                    assert(arguments.length === 3);\n\n                    assert(typeof count === 'number');\n                    afterCounts.push(count);\n\n                    assert(benchmark instanceof Benchmark);\n                    assert(result instanceof Result);\n                    assert(result.msecs.length === 3);\n                },\n                after(results) {\n                    assert(arguments.length === 1);\n\n                    results.forEach(x => {\n                        assert(x instanceof Result);\n                        assert(x.msecs.length === 3);\n                    });\n                },\n                benchmarkDefault: {\n                    number: 3,\n                    fun() {},\n                    after() {},\n                },\n            };\n\n            const s = new Suite(options);\n\n            s.add({});\n            s.add({});\n\n            const results = await s.run();\n            results.forEach(x => {\n                assert(x instanceof Result);\n                assert(x.msecs.length === 3);\n            });\n\n            assert.deepStrictEqual(beforeCounts, [0, 1]);\n            assert.deepStrictEqual(afterCounts, [0, 1]);\n        };\n\n        it('arguments for methods', function() {\n            return argumentsTest({parallel: false});\n        });\n\n        it('arguments for methods (enabled parallel)', function() {\n            return argumentsTest({parallel: true});\n        });\n    });\n});\n",
    "static": true,
    "longname": "/home/ena/AsyncMark/test/suite.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 85,
    "kind": "test",
    "name": "describe28",
    "testId": 28,
    "memberof": "test/suite.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/suite.js~describe28",
    "access": null,
    "description": "Suite",
    "lineNumber": 9,
    "testTargets": [
      "Suite"
    ]
  },
  {
    "__docId__": 86,
    "kind": "test",
    "name": "describe29",
    "testId": 29,
    "memberof": "test/suite.js~describe28",
    "testDepth": 1,
    "static": true,
    "longname": "test/suite.js~describe28.describe29",
    "access": null,
    "description": "#constructor",
    "lineNumber": 10
  },
  {
    "__docId__": 87,
    "kind": "test",
    "name": "it30",
    "testId": 30,
    "memberof": "test/suite.js~describe28.describe29",
    "testDepth": 2,
    "static": true,
    "longname": "test/suite.js~describe28.describe29.it30",
    "access": null,
    "description": "default values",
    "lineNumber": 11
  },
  {
    "__docId__": 88,
    "kind": "test",
    "name": "it31",
    "testId": 31,
    "memberof": "test/suite.js~describe28.describe29",
    "testDepth": 2,
    "static": true,
    "longname": "test/suite.js~describe28.describe29.it31",
    "access": null,
    "description": "options",
    "lineNumber": 19
  },
  {
    "__docId__": 89,
    "kind": "test",
    "name": "it32",
    "testId": 32,
    "memberof": "test/suite.js~describe28.describe29",
    "testDepth": 2,
    "static": true,
    "longname": "test/suite.js~describe28.describe29.it32",
    "access": null,
    "description": "functions",
    "lineNumber": 34
  },
  {
    "__docId__": 90,
    "kind": "test",
    "name": "it33",
    "testId": 33,
    "memberof": "test/suite.js~describe28",
    "testDepth": 1,
    "static": true,
    "longname": "test/suite.js~describe28.it33",
    "access": null,
    "description": "#addBenchmark",
    "lineNumber": 80,
    "testTargets": [
      "Suite#addBenchmark"
    ]
  },
  {
    "__docId__": 91,
    "kind": "test",
    "name": "it34",
    "testId": 34,
    "memberof": "test/suite.js~describe28",
    "testDepth": 1,
    "static": true,
    "longname": "test/suite.js~describe28.it34",
    "access": null,
    "description": "#addSuite",
    "lineNumber": 98,
    "testTargets": [
      "Suite#addSuite"
    ]
  },
  {
    "__docId__": 92,
    "kind": "test",
    "name": "describe35",
    "testId": 35,
    "memberof": "test/suite.js~describe28",
    "testDepth": 1,
    "static": true,
    "longname": "test/suite.js~describe28.describe35",
    "access": null,
    "description": "#add",
    "lineNumber": 117,
    "testTargets": [
      "Suite#add"
    ]
  },
  {
    "__docId__": 93,
    "kind": "test",
    "name": "it36",
    "testId": 36,
    "memberof": "test/suite.js~describe28.describe35",
    "testDepth": 2,
    "static": true,
    "longname": "test/suite.js~describe28.describe35.it36",
    "access": null,
    "description": "Benchmark",
    "lineNumber": 118
  },
  {
    "__docId__": 94,
    "kind": "test",
    "name": "it37",
    "testId": 37,
    "memberof": "test/suite.js~describe28.describe35",
    "testDepth": 2,
    "static": true,
    "longname": "test/suite.js~describe28.describe35.it37",
    "access": null,
    "description": "Suite",
    "lineNumber": 129
  },
  {
    "__docId__": 95,
    "kind": "test",
    "name": "it38",
    "testId": 38,
    "memberof": "test/suite.js~describe28.describe35",
    "testDepth": 2,
    "static": true,
    "longname": "test/suite.js~describe28.describe35.it38",
    "access": null,
    "description": "function",
    "lineNumber": 142
  },
  {
    "__docId__": 96,
    "kind": "test",
    "name": "it39",
    "testId": 39,
    "memberof": "test/suite.js~describe28.describe35",
    "testDepth": 2,
    "static": true,
    "longname": "test/suite.js~describe28.describe35.it39",
    "access": null,
    "description": "function with override default",
    "lineNumber": 171
  },
  {
    "__docId__": 97,
    "kind": "test",
    "name": "it40",
    "testId": 40,
    "memberof": "test/suite.js~describe28.describe35",
    "testDepth": 2,
    "static": true,
    "longname": "test/suite.js~describe28.describe35.it40",
    "access": null,
    "description": "object",
    "lineNumber": 201
  },
  {
    "__docId__": 98,
    "kind": "test",
    "name": "it41",
    "testId": 41,
    "memberof": "test/suite.js~describe28.describe35",
    "testDepth": 2,
    "static": true,
    "longname": "test/suite.js~describe28.describe35.it41",
    "access": null,
    "description": "object with override default",
    "lineNumber": 233
  },
  {
    "__docId__": 99,
    "kind": "test",
    "name": "describe42",
    "testId": 42,
    "memberof": "test/suite.js~describe28",
    "testDepth": 1,
    "static": true,
    "longname": "test/suite.js~describe28.describe42",
    "access": null,
    "description": "#run",
    "lineNumber": 267,
    "testTargets": [
      "Suite#run"
    ]
  },
  {
    "__docId__": 100,
    "kind": "test",
    "name": "describe43",
    "testId": 43,
    "memberof": "test/suite.js~describe28.describe42",
    "testDepth": 2,
    "static": true,
    "longname": "test/suite.js~describe28.describe42.describe43",
    "access": null,
    "description": "call methods order",
    "lineNumber": 268
  },
  {
    "__docId__": 101,
    "kind": "test",
    "name": "it44",
    "testId": 44,
    "memberof": "test/suite.js~describe28.describe42.describe43",
    "testDepth": 3,
    "static": true,
    "longname": "test/suite.js~describe28.describe42.describe43.it44",
    "access": null,
    "description": "empty tests",
    "lineNumber": 269
  },
  {
    "__docId__": 102,
    "kind": "test",
    "name": "it45",
    "testId": 45,
    "memberof": "test/suite.js~describe28.describe42.describe43",
    "testDepth": 3,
    "static": true,
    "longname": "test/suite.js~describe28.describe42.describe43.it45",
    "access": null,
    "description": "empty tests (enabled parallel)",
    "lineNumber": 297
  },
  {
    "__docId__": 103,
    "kind": "test",
    "name": "it46",
    "testId": 46,
    "memberof": "test/suite.js~describe28.describe42.describe43",
    "testDepth": 3,
    "static": true,
    "longname": "test/suite.js~describe28.describe42.describe43.it46",
    "access": null,
    "description": "with test",
    "lineNumber": 326
  },
  {
    "__docId__": 104,
    "kind": "test",
    "name": "it47",
    "testId": 47,
    "memberof": "test/suite.js~describe28.describe42.describe43",
    "testDepth": 3,
    "static": true,
    "longname": "test/suite.js~describe28.describe42.describe43.it47",
    "access": null,
    "description": "with test (enabled parallel)",
    "lineNumber": 380
  },
  {
    "__docId__": 105,
    "kind": "test",
    "name": "it48",
    "testId": 48,
    "memberof": "test/suite.js~describe28.describe42",
    "testDepth": 2,
    "static": true,
    "longname": "test/suite.js~describe28.describe42.it48",
    "access": null,
    "description": "context handling",
    "lineNumber": 522
  },
  {
    "__docId__": 106,
    "kind": "test",
    "name": "it49",
    "testId": 49,
    "memberof": "test/suite.js~describe28.describe42",
    "testDepth": 2,
    "static": true,
    "longname": "test/suite.js~describe28.describe42.it49",
    "access": null,
    "description": "context handling (enabled parallel)",
    "lineNumber": 526
  },
  {
    "__docId__": 107,
    "kind": "test",
    "name": "it50",
    "testId": 50,
    "memberof": "test/suite.js~describe28.describe42",
    "testDepth": 2,
    "static": true,
    "longname": "test/suite.js~describe28.describe42.it50",
    "access": null,
    "description": "arguments for methods",
    "lineNumber": 589
  },
  {
    "__docId__": 108,
    "kind": "test",
    "name": "it51",
    "testId": 51,
    "memberof": "test/suite.js~describe28.describe42",
    "testDepth": 2,
    "static": true,
    "longname": "test/suite.js~describe28.describe42.it51",
    "access": null,
    "description": "arguments for methods (enabled parallel)",
    "lineNumber": 593
  }
]